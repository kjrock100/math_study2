# 4.6.2 Divide and Conquer 분석

이 문서는 **4.6.2 Divide and Conquer** 섹션의 내용을 분석하고 설명합니다. 이 섹션은 강한 귀납법(Strong Induction)이 가장 빛을 발하는 응용 분야인 **분할 정복(Divide and Conquer)** 전략과 그 증명 방법을 다룹니다.

## 1. 섹션 개요 (Overview)

분할 정복은 큰 문제를 작은 하위 문제들로 나누어 해결하는 전략입니다. 이진 탐색(Binary Search), 병합 정렬(Merge Sort) 등이 대표적입니다.
이때 하위 문제의 크기는 $n-1$이 아니라 $n/2$이거나 임의의 크기일 수 있습니다. 따라서 바로 전 단계만 참조하는 표준 귀납법으로는 증명이 불가능하며, **강한 귀납법**이 필수적입니다.

## 2. 예제: 초콜릿 바 문제 (The Chocolate Bar Example)

$n$개의 칸(square)으로 이루어진 초콜릿 바가 있습니다. 이 바를 쪼개서 모든 칸을 낱개로 분리하려면 총 몇 번 쪼개야(break) 할까요?

* **관찰:**
  * 1칸: 0번
  * 2칸: 1번
  * 3칸: 2번
  * ...
  * **추측:** $n$개의 칸을 분리하려면 항상 **$n-1$번** 쪼개야 한다.

## 3. 강한 귀납법을 이용한 증명

이 명제 $P(n)$을 증명하기 위해 강한 귀납법을 사용합니다.

### 3.1 기초 단계 (Base Case)

* $n=1$일 때, 이미 낱개이므로 쪼갤 필요가 없습니다. 0번 = $1-1$.
* 따라서 $P(1)$은 참입니다.

### 3.2 귀납 가정 (Inductive Hypothesis)

* $k \ge 1$인 임의의 정수 $k$에 대하여, **$1 \le j \le k$인 모든 $j$에 대해 $P(j)$가 참이라고 가정**합니다.
* 즉, $j$개의 칸을 가진 초콜릿 바는 $j-1$번 쪼개면 분리됩니다.

### 3.3 귀납 단계 (Inductive Step)

* $k+1$개의 칸을 가진 초콜릿 바를 고려합니다.
* 이 바를 한 번 쪼개면 두 개의 조각으로 나뉩니다.
* 한 조각의 크기를 $a$, 다른 조각의 크기를 $b$라고 합시다. ($a + b = k+1$)
* 이때 $1 \le a \le k$이고 $1 \le b \le k$이므로, **강한 귀납 가정**을 적용할 수 있습니다.
  * 크기 $a$인 조각을 분리하는 데 필요한 횟수: $a-1$번
  * 크기 $b$인 조각을 분리하는 데 필요한 횟수: $b-1$번
* **총 횟수** = (처음 1번) + ($a$ 조각 분리) + ($b$ 조각 분리)
    $$ 1 + (a-1) + (b-1) = a + b - 1 $$
* $a+b = k+1$이므로, 총 횟수는 $(k+1) - 1$번이 됩니다.
* 따라서 $P(k+1)$도 참입니다.

## 4. 요약

**4.6.2 Divide and Conquer**는 강한 귀납법의 실용적인 가치를 보여줍니다.

* **구조:** 문제를 임의의 크기($a, b$)로 나누는 상황에서는 표준 귀납법($k \to k+1$)을 사용할 수 없습니다.
* **해결:** "모든 작은 크기에 대해 성립한다"는 강한 가정을 통해, 문제를 어떻게 나누더라도 증명이 성립함을 보일 수 있습니다.
* 이 논리는 컴퓨터 과학에서 재귀 함수의 종료 조건과 정확성을 증명하는 기본 원리입니다.
