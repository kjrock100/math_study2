# 3.8.4 Counting Functions 분석

이 문서는 **3.8.4 Counting Functions** 섹션의 내용을 분석하고 설명합니다. 이 섹션은 포함-배제의 원리(PIE)를 사용하여 특정 조건(특히 전사 함수, Surjective)을 만족하는 함수의 개수를 세는 방법을 다룹니다.

## 1. 섹션 개요 (Overview)

함수의 개수를 세는 것은 조합론의 기본 문제입니다.

* **모든 함수:** $n^m$ (곱의 법칙)
* **단사 함수 (One-to-one):** $P(n, m)$ (순열)
* **전사 함수 (Onto):** ?

전사 함수(공역의 모든 원소가 선택받는 함수)의 개수는 단순한 곱이나 순열 공식으로 구할 수 없습니다. 이 섹션에서는 PIE를 사용하여 이 난제를 해결합니다.

## 2. 전사 함수 (Surjective Functions)

### 2.1 문제 정의

* 정의역 $A$의 크기가 $m$, 공역 $B$의 크기가 $n$일 때 ($m \ge n$), 치역이 공역과 일치하는($Range(f) = B$) 함수의 개수는?
* 즉, 공역의 모든 원소 $y \in B$에 대해 적어도 하나의 $x \in A$가 존재하여 $f(x)=y$가 되어야 합니다.

### 2.2 PIE 적용 전략

"모든 원소가 선택받는다"는 조건은 직접 세기 어렵습니다. 대신 **"어떤 원소가 선택받지 못한다"**는 여사건을 이용합니다.

1. **전체 집합 ($S$):** $A$에서 $B$로 가는 모든 함수의 집합. $|S| = n^m$.
2. **조건 ($C_i$):** 공역의 원소 $y_i$가 치역에 포함되지 않는 경우 (Missed $y_i$).
3. **목표:** 어떤 원소도 빠뜨리지 않는 함수의 수, 즉 $|S| - |C_1 \cup C_2 \cup \dots \cup C_n|$을 구합니다.

## 3. 공식 유도 (Derivation)

### 3.1 교집합의 크기 계산

* $|C_i|$: 원소 $y_i$를 제외한 $n-1$개의 원소로 함수를 만듭니다.
  * 개수: $(n-1)^m$.
  * 선택 방법: $\binom{n}{1}$.
* $|C_i \cap C_j|$: 원소 $y_i, y_j$를 제외한 $n-2$개의 원소로 함수를 만듭니다.
  * 개수: $(n-2)^m$.
  * 선택 방법: $\binom{n}{2}$.
* **일반화:** $k$개의 원소를 제외하고 함수를 만드는 경우의 수는 $(n-k)^m$이며, 제외할 원소를 고르는 방법은 $\binom{n}{k}$입니다.

### 3.2 최종 공식

PIE 공식에 대입하면 다음과 같습니다.

$$ \text{Surjections} = n^m - \binom{n}{1}(n-1)^m + \binom{n}{2}(n-2)^m - \dots + (-1)^n \binom{n}{n}(n-n)^m $$

$$ = \sum_{k=0}^n (-1)^k \binom{n}{k} (n-k)^m $$

## 4. 제2종 스털링 수 (Stirling Numbers of the Second Kind)

이 문제는 **제2종 스털링 수**와 밀접한 관련이 있습니다.

* **정의:** 원소가 $m$개인 집합을 $n$개의 공집합이 아닌 부분집합들로 분할하는 방법의 수.
* **기호:** $S(m, n)$ 또는 $\left\{ \begin{matrix} m \\ n \end{matrix} \right\}$.
* **관계:** 전사 함수의 개수는 $n! \times S(m, n)$입니다.
  * 이유: $m$개의 원소를 $n$개의 그룹으로 나누고($S(m, n)$), 각 그룹을 공역의 원소 $n$개에 배정($n!$)하는 것과 같기 때문입니다.

## 5. 요약

**3.8.4 Counting Functions**는 PIE의 강력함을 다시 한번 보여줍니다.

* **핵심:** "모두 포함"이라는 조건은 "하나라도 제외"라는 조건들의 합집합을 전체에서 빼는 방식으로 해결합니다.
* 이 공식은 공과 상자 모델(Balls into Bins)에서 "빈 상자가 없는 경우"를 세는 문제와 동일합니다.
