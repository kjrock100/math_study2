# 1.1.2 Atomic and Molecular Statements 분석

이 문서는 **1.1.2 Atomic and Molecular Statements** 섹션의 내용을 분석하고 설명합니다. 이 섹션에서는 명제를 구조적 관점에서 분류하고, 단순한 명제들을 결합하여 복잡한 명제를 만드는 방법을 다룹니다.

## 1. 명제의 분류 (Classification of Statements)

수학적 진술(명제)은 그 복잡성에 따라 두 가지로 나뉩니다.

### 1.1 원자 명제 (Atomic Statements)

* **정의:** 더 이상 작은 논리적 단위로 쪼갤 수 없는 가장 단순한 형태의 명제입니다.
* **특징:** 내부에 논리 연산자(그리고, 또는, 만약~라면 등)를 포함하지 않습니다.
* **예시:**
  * "$P$: 2는 짝수이다."
  * "$Q$: 5는 3보다 크다."

### 1.2 분자 명제 (Molecular Statements)

* **정의:** 하나 이상의 원자 명제를 **논리 연산자(Logical Connectives)**로 연결하여 만든 복합 명제입니다.
* **특징:** 전체 명제의 참/거짓은 구성 요소인 원자 명제들의 진리값과 연산자의 규칙에 의해 결정됩니다.
* **예시:**
  * "$P \land Q$: 2는 짝수이고, 5는 3보다 크다."

## 2. 논리 연산자 (Logical Connectives)

원자 명제를 결합하여 분자 명제를 만드는 도구들입니다.

| 연산자 이름 | 기호 | 의미 | 설명 |
| :--- | :---: | :--- | :--- |
| **부정 (Negation)** | $\neg P$ | NOT | $P$가 참이면 거짓, 거짓이면 참이 됩니다. (단항 연산자) |
| **논리곱 (Conjunction)** | $P \land Q$ | AND | $P$와 $Q$가 **모두 참**일 때만 참입니다. |
| **논리합 (Disjunction)** | $P \lor Q$ | OR | $P$와 $Q$ 중 **하나라도 참**이면 참입니다. (포괄적 OR) |
| **함축 (Implication)** | $P \rightarrow Q$ | IF...THEN | $P$가 참이고 $Q$가 거짓일 때만 **거짓**입니다. |
| **쌍조건 (Biconditional)** | $P \leftrightarrow Q$ | IFF | $P$와 $Q$의 진리값이 **같을 때** 참입니다. |

## 3. 핵심 분석 및 주의사항

### 3.1 포괄적 OR vs 배타적 OR

* 수학에서의 **OR ($\lor$)**는 기본적으로 **포괄적(Inclusive)**입니다. "A 또는 B"는 둘 다 참인 경우도 포함합니다.
* 일상생활의 "커피 또는 차를 드시겠습니까?"(둘 중 하나만 선택)는 **배타적 OR (XOR, $\oplus$)**이며, 수학적 OR와 구별해야 합니다.

### 3.2 함축(Implication)의 진리값

* $P \rightarrow Q$에서 가정($P$)이 거짓이면, 결론($Q$)의 참/거짓 여부와 상관없이 전체 명제는 **참(True)**으로 간주합니다. 이를 **무의미한 참(Vacuously True)**이라고 합니다.
  * *예: "1이 2라면, 나는 날 수 있다."는 참인 명제입니다.*

## 4. 컴퓨터 과학과의 연결

* **복합 조건문:** 프로그래밍에서 `if (x > 0 && y < 10)`과 같은 구문은 두 개의 원자 명제(`x > 0`, `y < 10`)를 논리곱(`&&`)으로 연결한 분자 명제입니다.
* **단락 평가 (Short-circuit Evaluation):**
  * `P && Q`에서 `P`가 거짓이면 `Q`를 평가하지 않고 전체를 거짓으로 처리합니다.
  * `P || Q`에서 `P`가 참이면 `Q`를 평가하지 않고 전체를 참으로 처리합니다.

## 요약

**1.1.2 Atomic and Molecular Statements**는 논리를 조립하는 방법을 배웁니다. 우리는 원자 명제라는 벽돌과 논리 연산자라는 시멘트를 사용하여 거대한 논리의 구조물(증명, 알고리즘)을 쌓아 올릴 수 있습니다.
