# 13.2 실전 문제 (Practice Problems)

## 1. 개요 (Overview)

이 장에서는 13.1장에서 다룬 속력, 거리, 시간의 기본 개념과 상대 속도 원리를 바탕으로, **원형 트랙(Circular Track)**, **복합 구간 이동**, **시차를 둔 출발** 등 더욱 심화된 실전 문제들을 다룹니다.

## 2. 주요 문제 유형 (Key Problem Types)

### 2.1 원형 트랙 (Circular Track)

직선 도로와 달리 끝이 없이 계속 도는 형태입니다.

- **반대 방향:** 둘레(Circumference)를 두 속력의 **합**으로 나눕니다. (만나는 주기)
- **같은 방향:** 둘레를 두 속력의 **차**로 나눕니다. (따라잡는 주기)

### 2.2 구간별 속력이 다른 경우 (Multi-stage Journey)

전체 평균 속력을 구할 때 가장 주의해야 합니다.

- 각 구간의 **거리**와 **시간**을 각각 구한 뒤, $\frac{\text{Total Distance}}{\text{Total Time}}$ 공식을 적용합니다.

### 2.3 시차를 둔 출발 (Delayed Start)

한 사람이 먼저 출발하고 나중에 다른 사람이 출발하는 경우입니다.

- 나중 사람이 출발하는 시점에서의 **거리 차이(Gap)**를 먼저 계산해야 합니다.

## 3. 예제 문제 및 풀이 (Sample Problems & Solutions)

### 문제 1: 원형 트랙에서 만나기

둘레가 400m인 트랙에서 A는 3m/s, B는 5m/s의 속력으로 같은 지점에서 **반대 방향**으로 동시에 출발했다. 출발 후 처음 만나는 시간은?

- **상대 속도:** $3 + 5 = 8$ m/s.
- **거리:** 400m.
- **시간:** $\frac{400}{8} = 50$초.

### 문제 2: 원형 트랙에서 따라잡기

위와 같은 트랙(400m)에서 A(3m/s)와 B(5m/s)가 **같은 방향**으로 출발했다. B가 A를 처음으로 한 바퀴 따라잡는 데 걸리는 시간은?

- **상대 속도:** $5 - 3 = 2$ m/s.
- **거리 차이:** 한 바퀴(400m)를 더 돌아야 만남.
- **시간:** $\frac{400}{2} = 200$초.

### 문제 3: 구간별 평균 속력

철수가 처음 2시간 동안은 60km/h로, 다음 3시간 동안은 40km/h로 운전했다. 전체 평균 속력은?

- **구간 1:** 거리 $60 \times 2 = 120$km.
- **구간 2:** 거리 $40 \times 3 = 120$km.
- **총 거리:** $120 + 120 = 240$km.
- **총 시간:** $2 + 3 = 5$시간.
- **평균 속력:** $\frac{240}{5} = 48$ km/h.

## 4. 코드 구현 (Code Implementation)

Python을 사용하여 원형 트랙에서 두 물체가 만나는 지점과 횟수를 시뮬레이션하는 함수입니다.

```python
def solve_circular_track(circumference, v1, v2, direction='opposite'):
    """
    원형 트랙에서 두 물체가 처음 만나는 시간 계산
    direction: 'opposite' (반대) or 'same' (같은)
    """
    if direction == 'opposite':
        relative_speed = v1 + v2
    else:
        relative_speed = abs(v1 - v2)

    if relative_speed == 0:
        return float('inf') # 영원히 못 만남 (같은 속도, 같은 방향)

    time_to_meet = circumference / relative_speed
    return time_to_meet

def simulate_meetings(circumference, v1, v2, total_time):
    """
    주어진 시간 동안 반대 방향으로 돌 때 만나는 횟수 계산
    """
    meet_interval = solve_circular_track(circumference, v1, v2, 'opposite')
    return int(total_time // meet_interval)

# 테스트
track_len = 400
speed_a = 3
speed_b = 5

# 반대 방향
t_opposite = solve_circular_track(track_len, speed_a, speed_b, 'opposite')
print(f"Opposite direction meeting time: {t_opposite}s") # Expected: 50.0

# 같은 방향
t_same = solve_circular_track(track_len, speed_a, speed_b, 'same')
print(f"Same direction catch-up time: {t_same}s") # Expected: 200.0

# 10분(600초) 동안 만나는 횟수 (반대 방향)
meetings = simulate_meetings(track_len, speed_a, speed_b, 600)
print(f"Meetings in 10 mins: {meetings}") # Expected: 600 // 50 = 12
```

## 5. 요약 (Summary)

- **원형 트랙:** 직선 문제와 달리 '거리 차이'가 '트랙의 둘레'가 되는 순간 만납니다.
- **평균 속력:** 시간을 기준으로 가중 평균(Weighted Average)을 구하는 것과 같습니다. ($\frac{d_1+d_2}{t_1+t_2}$)
- **상대 속도:** 두 물체의 움직임을 하나의 속도로 환산하여 생각하면 계산이 훨씬 단순해집니다.
