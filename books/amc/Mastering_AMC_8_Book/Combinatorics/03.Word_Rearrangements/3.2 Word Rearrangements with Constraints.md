# 3.2 제약 조건이 있는 단어 배열 (Word Rearrangements with Constraints)

## 1. 개요 (Overview)

단순히 단어를 재배열하는 것을 넘어, "특정 문자들이 반드시 이웃해야 한다"거나 "특정 문자는 양 끝에 올 수 없다"와 같은 **제약 조건(Constraints)**이 주어지는 경우입니다. 3.1장에서 배운 '같은 것이 있는 순열' 공식에 논리적 전략(묶기, 끼워 넣기 등)을 결합하여 해결합니다.

## 2. 주요 전략 (Key Strategies)

### 2.1 묶음 전략 (Bundling / Glue Method)

특정 문자들이 **반드시 이웃(Together)**해야 할 때 사용합니다.

1.  이웃해야 하는 문자들을 하나의 '슈퍼 문자(Block)'로 묶습니다.
2.  묶음 안에서의 배열(내부 순열)을 고려합니다 (단, 묶인 문자가 서로 같다면 1가지).
3.  전체 덩어리를 하나의 단위로 보고 배열합니다.

### 2.2 끼워 넣기 전략 (Gap Method)

특정 문자들이 **이웃하면 안 될 때(Apart)** 사용합니다.

1.  제약 조건이 없는 문자들을 먼저 배열합니다.
2.  문자들 사이사이와 양 끝의 공간(Gap)을 파악합니다.
3.  이웃하면 안 되는 문자들을 그 공간에 배치합니다.

### 2.3 여사건 (Complementary Counting)

"적어도 두 개의 모음이 이웃하는 경우"와 같이 직접 세기 복잡할 때, 전체 경우에서 "모든 모음이 떨어져 있는 경우"를 빼서 계산합니다.

## 3. 예제 (Examples)

### 예제 1: 이웃해야 하는 경우 (Together)

단어 **"BANANA"**를 나열할 때, 두 개의 **'N'이 서로 이웃**하는 경우의 수는?

1.  **묶기:** (NN)을 하나의 덩어리 $X$로 생각합니다.
2.  **대상:** $\{B, A, A, A, X\}$ 총 5개.
3.  **구성:** 'A'가 3개, 나머지는 1개씩.
4.  **계산:**
    $$ \frac{5!}{3!} = \frac{120}{6} = 20 $$
    (참고: 묶음 (NN) 내부의 자리를 바꾸는 것은 구별되지 않으므로 곱하지 않습니다.)

### 예제 2: 이웃하지 않아야 하는 경우 (Apart)

단어 **"LULU"**를 나열할 때, 두 개의 **'L'이 서로 이웃하지 않는** 경우의 수는?

1.  **나머지 배열:** 'U', 'U'를 먼저 나열합니다.
    - 경우의 수: $\frac{2!}{2!} = 1$ (UU)
2.  **공간 확보:** $\_ U \_ U \_$ (공간 3곳)
3.  **끼워 넣기:** 3개의 공간 중 2곳을 선택하여 'L'을 배치합니다.
    - $\binom{3}{2} = 3$
4.  **총합:** $1 \times 3 = 3$ (LULU, LUUL, ULLU는 안됨 $\rightarrow$ ULUL, ULLU(X), LUUL(X)... 직접 나열: ULUL, ULLU(X), LUUL(X) -> 정확히는 LULU, ULUL, LUUL 중 LUUL은 LL이 붙지 않음. 정답은 ULUL, LULU, LUUL? 아님. Gap method로 다시 확인:
    - UU 배치 (1가지). 공간 3개 중 L 2개 선택. L끼리 구별 안됨. $\binom{3}{2}=3$.
    - 실제 나열: LULU, LUUL, ULUL. (모두 L이 떨어져 있음). 정답 3.

## 4. 코드 구현 (Code Implementation)

Python을 사용하여 제약 조건이 있는 순열을 필터링하는 방법입니다.

```python
from itertools import permutations

def count_constrained_arrangements(word, constraint_type, target_chars):
    # 1. 모든 고유한 순열 생성 (set으로 중복 제거)
    # permutations는 위치 기반이므로 같은 문자라도 다른 위치면 다르게 봄 -> set으로 문자열 변환 후 중복 제거
    unique_perms = set("".join(p) for p in permutations(word))

    count = 0
    target_block = "".join(target_chars) # 예: "NN"

    for p in unique_perms:
        if constraint_type == "together":
            # target_block이 문자열 안에 포함되어야 함
            if target_block in p:
                count += 1
        elif constraint_type == "apart":
            # target_chars의 문자들이 서로 붙어있으면 안 됨
            # 예: 'L'이 타겟이면 "LL"이 없어야 함
            # 주의: 타겟 문자가 3개 이상일 때도 고려해야 하지만, 여기선 단순화하여 "같은 문자끼리 붙지 않음"으로 가정
            is_apart = True
            for i in range(len(p) - 1):
                if p[i] in target_chars and p[i+1] in target_chars:
                    is_apart = False
                    break
            if is_apart:
                count += 1

    return count

# 테스트
print(f"BANANA (N together): {count_constrained_arrangements('BANANA', 'together', 'NN')}") # Expected: 20
print(f"LULU (L apart): {count_constrained_arrangements('LULU', 'apart', 'L')}")       # Expected: 3 (LULU, LUUL, ULUL) -> LUUL은 L이 떨어져있음.
```

## 5. 요약 (Summary)

- **이웃한다(Together):** 묶어서 하나로 취급한다. (내부 배열 주의)
- **이웃하지 않는다(Apart):** 나머지를 먼저 세우고 사이사이에 끼워 넣는다.
- **같은 것이 있는 순열:** 기본 공식($n! / \dots$)을 적용하되, 묶음 처리 후 전체 개수($n$)가 줄어드는 것을 잊지 말아야 한다.
