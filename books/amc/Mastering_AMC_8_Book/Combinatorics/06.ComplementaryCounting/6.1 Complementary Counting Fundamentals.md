# 6.1 여사건의 기초 (Complementary Counting Fundamentals)

## 1. 개요 (Overview)

여사건(Complementary Counting)은 우리가 원하는 경우의 수를 직접 세는 것이 너무 복잡하거나 많을 때, **전체 경우의 수에서 원하지 않는 경우의 수를 빼서** 구하는 전략입니다. 이 방법은 복잡한 문제를 단순화하는 가장 강력한 도구 중 하나입니다.

## 2. 핵심 원리 (Core Principle)

### 2.1 공식

$$ \text{원하는 경우(Target)} = \text{전체 경우(Total)} - \text{원하지 않는 경우(Unwanted)} $$

집합 기호로 표현하면 다음과 같습니다. ($U$: 전체 집합, $A$: 사건)
$$ n(A) = n(U) - n(A^c) $$

### 2.2 언제 사용하는가? (When to use)

다음과 같은 키워드가 문제에 등장하면 여사건을 가장 먼저 떠올려야 합니다.

- **"적어도 하나 (At least one)"**: 반대는 "하나도 없는 (None)"입니다.
- **"~가 아닌 (Not)"**: 부정형 조건은 전체에서 긍정형을 빼는 것이 쉽습니다.
- **"많아도 (At most)"**: 케이스가 너무 많을 때 반대쪽 케이스가 적은지 확인합니다.

## 3. 예제 (Examples)

### 예제 1: 동전 던지기 (Coin Toss)

동전 4개를 동시에 던질 때, **적어도 한 개가 앞면(Head)**이 나올 경우의 수는?

- **직접 세기:** (H가 1개) + (H가 2개) + (H가 3개) + (H가 4개) $\rightarrow$ 계산이 깁니다.
- **여사건 활용:**
  1.  **전체 경우:** $2^4 = 16$가지.
  2.  **반대 경우:** 앞면이 하나도 없는 경우 (모두 뒷면, TTTT) $\rightarrow$ 1가지.
  3.  **계산:** $16 - 1 = 15$가지.

### 예제 2: 곱이 짝수 (Product is Even)

집합 $\{1, 2, 3, 4, 5\}$에서 서로 다른 두 수를 뽑아 곱했을 때, 그 결과가 **짝수**일 경우의 수는?

- **원리:** 두 수의 곱이 짝수가 되려면 적어도 하나는 짝수여야 합니다. (짝$\times$짝, 짝$\times$홀, 홀$\times$짝)
- **여사건 활용:**
  1.  **전체 경우:** $\binom{5}{2} = 10$가지.
  2.  **반대 경우:** 곱이 홀수인 경우 (홀수$\times$홀수).
      - 홀수 집합 $\{1, 3, 5\}$에서 2개를 뽑는 경우 $\binom{3}{2} = 3$가지.
  3.  **계산:** $10 - 3 = 7$가지.

### 예제 3: 기하학적 여사건 (Geometric Complement)

정사각형 안에 색칠된 복잡한 영역의 넓이를 구할 때, 직접 구하기 어렵다면 **(전체 정사각형 넓이) - (색칠되지 않은 부분의 넓이)**로 구합니다.

## 4. 코드 구현 (Code Implementation)

Python을 사용하여 "적어도 하나" 조건의 문제를 시뮬레이션하고 여사건의 원리를 검증합니다.

```python
from itertools import product, combinations

def solve_coin_toss_complementary(n):
    # 1. 전체 경우의 수
    total_outcomes = 2 ** n

    # 2. 반대 경우 (모두 뒷면인 경우 1가지)
    unwanted_outcomes = 1

    return total_outcomes - unwanted_outcomes

def solve_product_even_complementary(numbers, r=2):
    # 1. 전체 조합의 수
    total_combs = len(list(combinations(numbers, r)))

    # 2. 반대 경우: 홀수끼리만 뽑는 경우
    odds = [x for x in numbers if x % 2 != 0]
    unwanted_combs = len(list(combinations(odds, r)))

    return total_combs - unwanted_combs

# 검증
print(f"동전 4개 적어도 앞면 1개: {solve_coin_toss_complementary(4)}") # 16 - 1 = 15

numbers = [1, 2, 3, 4, 5]
print(f"1~5 중 2개 곱이 짝수: {solve_product_even_complementary(numbers)}") # 10 - 3 = 7
```

## 5. 요약 (Summary)

- **Target = Total - Unwanted** 공식을 항상 기억하세요.
- 문제를 읽을 때 **"적어도(At least)"**라는 단어가 나오면 즉시 여사건을 고려해야 합니다.
- 반대 경우가 계산하기 훨씬 간단한지(케이스가 적은지) 확인하는 습관을 들이세요.
