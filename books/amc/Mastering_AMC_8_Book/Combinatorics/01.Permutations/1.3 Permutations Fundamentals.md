# 1.3 순열의 기초 (Permutations Fundamentals)

## 1. 개요 (Overview)

이 장에서는 앞서 배운 순열의 정의($P(n,r)$)와 팩토리얼($n!$)을 바탕으로, 실제 문제에서 자주 등장하는 기본적인 순열의 유형과 해결 전략을 다룹니다. 특히 **제약 조건(Restrictions)**이 있는 순열 문제를 해결하는 논리적 접근법에 집중합니다.

## 2. 주요 유형 분석 (Key Types Analysis)

### 2.1 일렬로 나열하기 (Linear Arrangements)

가장 기본적인 형태로, $n$개의 서로 다른 대상을 일렬로 줄 세우는 경우입니다.
$$ \text{Ways} = n! $$

### 2.2 이웃해야 하는 경우 (Items Together)

특정 대상들이 반드시 서로 붙어 있어야 하는 경우입니다. "묶음(Block)" 전략을 사용합니다.

1.  **묶기:** 이웃해야 하는 대상들을 하나의 덩어리로 취급합니다.
2.  **전체 배열:** 덩어리를 포함하여 전체를 배열합니다.
3.  **내부 배열:** 덩어리 안에서 대상들의 순서를 고려하여 곱합니다.

$$ \text{Total} = (\text{덩어리 포함 전체 개수})! \times (\text{덩어리 내부 개수})! $$

### 2.3 이웃하지 않아야 하는 경우 (Items Apart)

특정 대상들이 서로 붙어 있으면 안 되는 경우입니다. "끼워 넣기(Gap Method)" 전략을 사용합니다.

1.  **나머지 배열:** 제약 조건이 없는 대상들을 먼저 일렬로 배열합니다.
2.  **사이 공간 확보:** 배열된 대상들의 양 끝과 사이사이 공간(Gap)을 확인합니다.
3.  **끼워 넣기:** 이웃하면 안 되는 대상들을 확보된 공간 중 선택하여 배치합니다.

## 3. 예제 (Examples)

### 예제 1: 기본 배열

학생 5명(A, B, C, D, E)을 일렬로 세우는 방법의 수:
$$ 5! = 120 $$

### 예제 2: 묶음 순열 (Grouping)

A와 B가 반드시 이웃하게 서는 방법의 수:

1.  (AB)를 하나로 묶음 $\rightarrow$ {(AB), C, D, E} 총 4개 단위.
2.  4개 나열: $4! = 24$.
3.  (AB) 내부 자리 바꾸기: $2! = 2$.
4.  총 경우의 수: $24 \times 2 = 48$.

## 4. 코드 구현 (Code Implementation)

Python을 활용하여 제약 조건이 있는 순열을 시뮬레이션하고 검증할 수 있습니다.

### 4.1 이웃하는 조건 검증 (Checking "Together" Constraint)

```python
from itertools import permutations

items = ['A', 'B', 'C', 'D', 'E']
# 전체 순열 생성
perms = list(permutations(items))

count = 0
for p in perms:
    # A와 B의 인덱스 차이가 1이면 이웃함
    if abs(p.index('A') - p.index('B')) == 1:
        count += 1

print(f"A와 B가 이웃하는 경우의 수: {count}")
# 출력: 48
```

### 4.2 특정 위치 고정 (Fixed Positions)

예: A가 맨 앞에 오는 경우.

```python
count_fixed = 0
for p in perms:
    if p[0] == 'A':
        count_fixed += 1

print(f"A가 맨 앞에 오는 경우의 수: {count_fixed}")
# 이론적 계산: A 고정, 나머지 4명 배열 = 4! = 24
# 출력: 24
```

## 5. 요약 (Summary)

- **기본 순열:** $n!$
- **이웃할 때:** 묶어서 하나로 보고 배열 후, 묶음 내부 순서 곱하기.
- **이웃하지 않을 때:** 나머지를 먼저 배열하고 사이사이에 끼워 넣기.
- 문제의 제약 조건을 먼저 파악하고 적절한 전략(묶기 vs 끼워 넣기)을 선택하는 것이 중요합니다.
