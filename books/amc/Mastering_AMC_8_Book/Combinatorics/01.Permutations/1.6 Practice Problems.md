# 1.6 실전 문제 (Practice Problems)

## 1. 개요 (Overview)

이 장에서는 1.1부터 1.5까지 다룬 순열(Permutations), 팩토리얼(Factorials), 숫자 순열(Digit Permutations), 원순열(Circular Arrangements)의 개념을 종합하여 실제 AMC 8 수준의 문제들을 해결해 봅니다.

## 2. 주요 문제 유형 (Key Problem Types)

1.  **단순 나열:** 제약 조건이 없는 기본적인 순열 ($n!$).
2.  **이웃 조건:** 특정 대상이 이웃하거나 이웃하지 않아야 하는 경우.
3.  **숫자 만들기:** 0이 포함되거나 짝수/홀수 조건이 있는 정수 만들기.
4.  **원탁/목걸이:** 회전 대칭을 고려한 배열.
5.  **사전식 배열:** 알파벳 순서나 크기 순서로 나열했을 때의 위치 찾기.

## 3. 예제 문제 및 풀이 (Sample Problems & Solutions)

### 문제 1: 단어 배열 (Word Arrangements)

단어 "MATH"의 문자 4개를 일렬로 나열할 때, 모음(A)이 맨 앞에 오지 않는 경우의 수는?

- **전체 경우의 수:** $4! = 24$
- **A가 맨 앞에 오는 경우:** A를 고정하고 나머지 M, T, H 나열 $\rightarrow 3! = 6$
- **정답:** $24 - 6 = 18$

### 문제 2: 숫자 제약 (Digit Constraints)

숫자 $\{0, 1, 2, 3, 4\}$ 중 서로 다른 3개를 사용하여 만들 수 있는 3자리 짝수의 개수는?

- **Case 1: 일의 자리가 0인 경우** ($\square \square 0$)
  - 백의 자리: $\{1, 2, 3, 4\}$ (4개)
  - 십의 자리: 나머지 3개
  - $4 \times 3 = 12$
- **Case 2: 일의 자리가 2 또는 4인 경우**
  - 일의 자리 선택: 2가지 (2, 4)
  - 백의 자리: 0과 일의 자리 제외 (3가지)
  - 십의 자리: 나머지 (0 포함, 3가지)
  - $2 \times 3 \times 3 = 18$
- **정답:** $12 + 18 = 30$

### 문제 3: 원탁 회의 (Circular Meeting)

A, B, C, D, E, F 6명이 원탁에 앉을 때, A와 B가 서로 마주 보고 앉는 경우의 수는?

- **전략:** A를 고정시킵니다.
- B의 자리는 A의 맞은편으로 고정됩니다 (선택권 1가지).
- 나머지 4명(C, D, E, F)을 남은 4자리에 배치합니다 ($4!$).
- **정답:** $1 \times 1 \times 4! = 24$

## 4. 문제 해결 전략 (Problem Solving Strategies)

- **여사건(Complementary Counting):** "적어도 하나 ~인 경우"나 "~가 아닌 경우"를 구할 때, 전체에서 반대되는 경우를 빼는 것이 효율적입니다.
- **케이스 분류(Case Work):** 복잡한 제약 조건(특히 0이 포함된 짝수 문제)은 겹치지 않는 케이스로 나누어 풉니다.
- **고정하기(Fixing):** 원순열이나 특정 위치 조건이 있는 경우, 기준이 되는 대상을 먼저 배치하여 문제를 단순화합니다.

## 5. 코드 구현 (Code Implementation)

Python을 사용하여 위 문제들의 정답을 검증하는 코드입니다.

```python
from itertools import permutations

# 문제 1: "MATH"에서 A가 맨 앞에 오지 않는 경우
words = list(permutations("MATH"))
count_q1 = 0
for w in words:
    if w[0] != 'A':
        count_q1 += 1
print(f"문제 1 정답: {count_q1}")  # Expected: 18

# 문제 2: {0,1,2,3,4}로 만드는 3자리 짝수
digits = [0, 1, 2, 3, 4]
perms_q2 = list(permutations(digits, 3))
count_q2 = 0
for p in perms_q2:
    # 맨 앞자리 0 제외 (3자리 수 조건)
    if p[0] == 0:
        continue
    # 짝수 조건 (일의 자리)
    if p[2] % 2 == 0:
        count_q2 += 1
print(f"문제 2 정답: {count_q2}")  # Expected: 30

# 문제 3: 6명 원탁, A와 B 마주보기
# A를 0번 인덱스에 고정했다고 가정 (원순열 특성)
others = ['B', 'C', 'D', 'E', 'F']
linear_perms = list(permutations(others))
count_q3 = 0
for p in linear_perms:
    # 전체 배열: ('A',) + p
    full_table = ('A',) + p
    # 6명일 때 마주보는 인덱스 차이는 3 (0-3, 1-4, 2-5)
    if abs(full_table.index('A') - full_table.index('B')) == 3:
        count_q3 += 1
print(f"문제 3 정답: {count_q3}")  # Expected: 24
```

## 6. 요약 (Summary)

- 실전 문제는 여러 개념이 혼합되어 출제됩니다.
- 공식을 맹목적으로 적용하기보다, 문제의 조건을 분석하여 적절한 전략(케이스 분류, 여사건 등)을 선택해야 합니다.
- 검산 시 작은 숫자로 직접 나열해보거나, 논리적 단계가 맞는지 확인하는 습관이 중요합니다.
