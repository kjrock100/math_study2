# 1.1 순열 (Permutations) 정의 및 분석

## 1. 개요 (Overview)

순열(Permutation)은 이산 수학(Discrete Mathematics)과 조합론(Combinatorics)의 기초가 되는 개념으로, **순서가 부여된** 객체들의 배열을 의미합니다. 집합에서 원소를 선택할 때 **순서가 중요(Order matters)**하다는 점이 조합(Combination)과의 가장 큰 차이점입니다.

## 2. 정의 (Definition)

서로 다른 $n$개의 원소를 가진 집합에서 $r$개를 선택하여 일렬로 배열하는 것을 **$n$개에서 $r$개를 택한 순열($r$-permutation of $n$ elements)**이라고 합니다.

이를 기호로 다음과 같이 표기합니다:
$$ P(n, r) \quad \text{또는} \quad \_nP_r $$

### 핵심 조건

1.  **원소의 구별:** $n$개의 원소는 서로 다릅니다.
2.  **순서의 중요성:** 배열된 순서가 다르면 다른 경우로 취급합니다. (예: $\{1, 2\} \neq \{2, 1\}$)
3.  **비복원 추출:** 일반적인 순열 정의에서는 한 번 선택된 원소를 다시 선택하지 않습니다 (중복 순열 제외).

## 3. 공식 (Formula)

순열의 수는 곱의 법칙(Product Rule)에 의해 유도되며, 팩토리얼(Factorial)을 사용하여 표현할 수 있습니다.

$$ P(n, r) = n \times (n-1) \times (n-2) \times \dots \times (n-r+1) $$

이를 팩토리얼 표기법으로 정리하면 다음과 같습니다:

$$ P(n, r) = \frac{n!}{(n-r)!} $$

- 단, $0 \le r \le n$
- $n! = n \times (n-1) \times \dots \times 2 \times 1$ (단, $0! = 1$)

### 특수 사례

- **$r = n$ 인 경우:** $n$개의 원소를 모두 나열하는 경우의 수입니다.
  $$ P(n, n) = n! $$
- **$r = 0$ 인 경우:** 아무것도 선택하지 않는 방법은 1가지(공집합)입니다.
  $$ P(n, 0) = 1 $$

## 4. 예시 (Example)

집합 $S = \{A, B, C\}$ ($n=3$)에서 2개의 원소를 선택하여 나열하는 경우 ($r=2$):

1.  첫 번째 자리에 올 수 있는 원소: 3개 (A, B, C)
2.  두 번째 자리에 올 수 있는 원소: 2개 (첫 번째에서 선택한 것 제외)

가능한 모든 순열:

- (A, B), (A, C)
- (B, A), (B, C)
- (C, A), (C, B)

총 개수: $3 \times 2 = 6$

## 5. 코드 구현 (Code Implementation)

알고리즘 문제 해결이나 데이터 처리 시 순열을 구현하는 방법입니다.

### 5.1 Python `math` 모듈을 이용한 개수 계산

단순히 경우의 수(값)만 필요한 경우 사용합니다.

```python
import math

n = 5
r = 3

# Python 3.8 이상부터 math.perm 지원
count = math.perm(n, r)
print(f"P({n}, {r})의 경우의 수: {count}")
# 출력: 60
```

### 5.2 Python `itertools`를 이용한 순열 생성

실제 배열된 리스트가 필요한 경우 사용합니다.

```python
from itertools import permutations

items = ['A', 'B', 'C']
r = 2

# 순열 객체 생성 및 리스트 변환
perm_list = list(permutations(items, r))

print(f"생성된 순열: {perm_list}")
# 출력: [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]
```

## 6. 요약 (Summary)

- **순열**은 **순서**가 있는 배열이다.
- 공식은 $P(n, r) = \frac{n!}{(n-r)!}$ 이다.
- 코딩 테스트 등에서는 `itertools.permutations`를 활용하여 쉽게 구현할 수 있으나, $n$이 커질 경우 시간 복잡도($O(n!)$)가 급격히 증가하므로 주의해야 한다.
