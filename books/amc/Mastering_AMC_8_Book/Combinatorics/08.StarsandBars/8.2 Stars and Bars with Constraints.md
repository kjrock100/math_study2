# 8.2 제약 조건이 있는 중복 조합 (Stars and Bars with Constraints)

## 1. 개요 (Overview)

기본적인 중복 조합 문제에서 변수들에 **최소 개수(Lower Bound)**나 **최대 개수(Upper Bound)** 제한이 있는 경우를 다룹니다. 최소 조건은 **치환(Substitution)**을 통해 해결하며, 최대 조건은 **포함-배제 원리(PIE)**나 여사건을 활용합니다.

## 2. 최소 개수 조건 (Lower Bound Constraints)

각 상자에 적어도 $a_i$개 이상 들어가야 하는 경우입니다.
$$ x_1 + x_2 + \dots + x_k = n \quad (x_i \ge a_i) $$

### 해결 전략: 미리 나누어 주기

1.  각 상자에 요구되는 최소 개수($a_i$)만큼 미리 나누어 줍니다.
2.  남은 개수 $n' = n - \sum a_i$를 구합니다.
3.  남은 개수를 제약 없는 중복 조합(음이 아닌 정수해)으로 분배합니다.

$$ \binom{n' + k - 1}{k - 1} $$

## 3. 최대 개수 조건 (Upper Bound Constraints)

특정 상자에 $m$개까지만 넣을 수 있는 경우입니다.
$$ x_1 + x_2 + \dots + x_k = n \quad (0 \le x_i \le m) $$

### 해결 전략: 여사건과 포함-배제 (PIE)

직접 구하기 어렵기 때문에 전체 경우에서 **조건을 위반하는 경우**를 뺍니다.

1.  **전체 경우:** 제약 없이 $n$개를 나누는 경우의 수.
2.  **위반 조건:** $x_i \ge m + 1$인 경우.
3.  **PIE 적용:** 하나가 위반하는 경우, 두 개가 동시에 위반하는 경우 등을 고려하여 계산합니다.

## 4. 예제 (Examples)

### 예제 1: 최소 조건 (Lower Bound)

사과 15개를 3명(A, B, C)에게 나누어 줄 때, A는 1개 이상, B는 2개 이상, C는 3개 이상 받아야 한다.

- **미리 주기:** $1 + 2 + 3 = 6$개를 미리 줍니다.
- **남은 개수:** $15 - 6 = 9$개.
- **분배:** 9개를 3명에게 자유롭게 분배 ($x \ge 0$).
  $$ \binom{9 + 3 - 1}{3 - 1} = \binom{11}{2} = 55 $$

### 예제 2: 최대 조건 (Upper Bound)

사탕 6개를 3명에게 나누어 줄 때, 한 사람이 **2개 이하**로 받아야 한다. ($x_i \le 2$)

- **전체 경우:** $\binom{6+3-1}{2} = \binom{8}{2} = 28$.
- **위반 조건:** 누군가 3개 이상($\ge 3$) 받는 경우.
- **하나 위반 ($x_i \ge 3$):** 3개를 미리 주고 남은 3개 분배. $\binom{3+2}{2} = 10$. 3명이므로 $10 \times 3 = 30$.
  - (주의: 전체 경우보다 위반 경우가 더 크게 계산된 것은 중복 때문입니다.)
- **둘 위반 ($x_i, x_j \ge 3$):** 6개를 미리 주고 남은 0개 분배. $\binom{0+2}{2} = 1$. 3명 중 2명 선택($\binom{3}{2}=3$)이므로 $1 \times 3 = 3$.
- **셋 위반:** 불가능 ($3+3+3=9 > 6$).
- **위반 총합 (PIE):** $30 - 3 = 27$.
- **정답:** $28 - 27 = 1$. (유일한 해: 2, 2, 2)

## 5. 코드 구현 (Code Implementation)

Python을 사용하여 상한/하한 제약 조건이 있는 중복 조합 문제를 해결하는 재귀(DP) 함수입니다.

```python
import math

def count_distributions_recursive(n, k, min_limits, max_limits, memo=None):
    """
    n: 나누어 줄 아이템 수
    k: 남은 그룹(상자) 수
    min_limits: 각 그룹별 최소 개수 리스트 (길이 k 이상이어야 함)
    max_limits: 각 그룹별 최대 개수 리스트 (길이 k 이상이어야 함)
    """
    if memo is None:
        memo = {}

    state = (n, k)
    if state in memo:
        return memo[state]

    # Base case: 마지막 그룹
    if k == 1:
        if min_limits[0] <= n <= max_limits[0]:
            return 1
        else:
            return 0

    count = 0
    # 현재 그룹(첫 번째)에 줄 수 있는 개수 i 반복
    current_min = min_limits[0]
    current_max = max_limits[0]

    for i in range(current_min, current_max + 1):
        if n - i >= 0:
            count += count_distributions_recursive(
                n - i,
                k - 1,
                min_limits[1:],
                max_limits[1:],
                memo
            )

    memo[state] = count
    return count

# 예제 1: n=15, k=3, min=[1, 2, 3], max=[15, 15, 15]
print(f"예제 1 (Lower Bound): {count_distributions_recursive(15, 3, [1, 2, 3], [15]*3)}")
# Expected: 55

# 예제 2: n=6, k=3, min=[0, 0, 0], max=[2, 2, 2]
print(f"예제 2 (Upper Bound): {count_distributions_recursive(6, 3, [0]*3, [2]*3)}")
# Expected: 1
```

## 6. 요약 (Summary)

- **최소 조건:** $n$에서 미리 빼고 시작한다. (치환)
- **최대 조건:** 전체에서 위반하는 경우를 뺀다. (PIE)
- **복합 조건:** 코드로 해결할 때는 재귀(DP)나 생성함수(다항식 곱셈) 방식이 유용하다.
