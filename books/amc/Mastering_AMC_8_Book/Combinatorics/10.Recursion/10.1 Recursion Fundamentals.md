# 10.1 재귀의 기초 (Recursion Fundamentals)

## 1. 개요 (Overview)

재귀(Recursion)는 어떤 문제를 해결하기 위해 **자기 자신을 다시 호출**하여 더 작은 크기의 하위 문제를 해결하는 방법입니다. 수학의 점화식(Recurrence Relation)과 컴퓨터 과학의 알고리즘에서 매우 중요한 개념으로, 복잡한 문제를 단순하고 반복적인 규칙으로 표현할 수 있게 해줍니다.

## 2. 핵심 구성 요소 (Core Components)

올바른 재귀 함수를 만들기 위해서는 반드시 다음 두 가지 요소가 필요합니다.

### 2.1 기저 사례 (Base Case)

재귀 호출을 멈추는 **종료 조건**입니다. 더 이상 쪼갤 수 없는 가장 단순한 형태의 문제에 대한 답을 직접 정의합니다. 기저 사례가 없으면 무한 루프(Infinite Loop)에 빠지게 됩니다.

- 예: $0! = 1$, $F_1 = 1$

### 2.2 재귀 단계 (Recursive Step)

문제를 더 작은 문제로 나누어 자기 자신을 호출하는 부분입니다. 수학적 규칙(점화식)이 이곳에 적용됩니다.

- 예: $n! = n \times (n-1)!$

## 3. 대표적인 예제 (Examples)

### 예제 1: 팩토리얼 (Factorial)

$n!$은 1부터 $n$까지의 곱입니다.

- **점화식:** $a_n = n \times a_{n-1}$
- **기저 사례:** $a_0 = 1$ (또는 $a_1 = 1$)
- **과정:** $4! \rightarrow 4 \times 3! \rightarrow 4 \times 3 \times 2! \rightarrow \dots \rightarrow 24$

### 예제 2: 피보나치 수열 (Fibonacci Sequence)

앞의 두 수를 더해서 다음 수를 만드는 수열입니다. ($1, 1, 2, 3, 5, 8, \dots$)

- **점화식:** $F_n = F_{n-1} + F_{n-2}$
- **기저 사례:** $F_1 = 1, F_2 = 1$

### 예제 3: 계단 오르기 (Climbing Stairs)

한 번에 1계단 또는 2계단을 오를 수 있을 때, $n$개의 계단을 오르는 방법의 수는?

- $n$번째 계단에 도달하려면, $(n-1)$번째에서 1계단 오르거나, $(n-2)$번째에서 2계단 올라야 합니다.
- **점화식:** $S_n = S_{n-1} + S_{n-2}$ (피보나치와 동일한 구조)
- **기저 사례:** $S_1 = 1$ (1), $S_2 = 2$ (1+1, 2)

## 4. 코드 구현 (Code Implementation)

Python을 사용하여 팩토리얼과 피보나치 수열을 재귀적으로 구현하는 방법입니다.

```python
def factorial_recursive(n):
    # 1. Base Case: 종료 조건
    if n == 0 or n == 1:
        return 1

    # 2. Recursive Step: 자기 자신 호출
    return n * factorial_recursive(n - 1)

def fibonacci_recursive(n):
    # 1. Base Case
    if n == 1 or n == 2:
        return 1

    # 2. Recursive Step
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)

# 테스트
print(f"5! = {factorial_recursive(5)}")        # 출력: 120
print(f"Fibonacci(6) = {fibonacci_recursive(6)}") # 출력: 8 (1, 1, 2, 3, 5, 8)
```

### 주의사항 (Efficiency Note)

단순한 재귀 구현(특히 피보나치)은 동일한 계산을 중복해서 수행하므로 $n$이 커지면 매우 느려질 수 있습니다. 이를 해결하기 위해 **메모이제이션(Memoization)**이나 반복문(Iterative) 방식을 사용하기도 합니다.

## 5. 문제 해결 전략 (Problem Solving Strategy)

1.  **패턴 찾기:** $n=1, 2, 3, \dots$일 때의 값을 직접 구해보고 규칙을 찾습니다.
2.  **관계식 세우기:** $n$번째 항을 이전 항들($n-1, n-2 \dots$)로 표현해 봅니다.
3.  **초기값 설정:** 규칙이 적용되지 않는 가장 작은 값들을 정의합니다.

## 6. 요약 (Summary)

- **재귀:** 큰 문제를 작은 문제로 쪼개서 푼다.
- **필수 요소:** 기저 사례(종료) + 재귀 단계(반복).
- **응용:** 수열, 계단 오르기, 하노이의 탑 등 다양한 문제 해결의 기초가 된다.
