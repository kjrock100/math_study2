# 10.2 제약 조건이 있는 재귀 (Recursion with Constraints)

## 1. 개요 (Overview)

기본적인 재귀 문제에 **제약 조건(Constraints)**이 추가된 형태입니다. 예를 들어, 경로 세기 문제에서 특정 지점을 지날 수 없거나, 수열을 만들 때 특정 숫자를 이웃하게 배치할 수 없는 경우 등이 해당됩니다. 이러한 제약은 재귀 함수의 **매개변수(Parameters)**를 추가하거나, **가지치기(Pruning)**를 통해 해결할 수 있습니다.

## 2. 주요 전략 (Key Strategies)

### 2.1 상태에 제약 포함 (State with Constraints)

재귀 함수의 매개변수에 제약 조건과 관련된 정보를 추가하여, 각 호출 단계에서 조건을 만족하는지 확인할 수 있도록 합니다.

- 예: `solve(current_position, last_item_used)`

### 2.2 가지치기 (Pruning)

재귀 호출 과정에서 제약 조건을 위반하는 경로가 발견되면, 더 이상 깊이 탐색하지 않고 해당 분기(Branch)를 중단합니다. 이는 불필요한 계산을 줄여 효율성을 높입니다.

### 2.3 기저 사례 수정 (Modified Base Case)

재귀의 종료 조건인 기저 사례에서, 최종 결과가 주어진 제약 조건을 만족하는지 한 번 더 확인합니다.

## 3. 예제 (Examples)

### 예제 1: 장애물이 있는 경로 세기 (Path Counting with Obstacles)

격자 위에서 최단 경로를 셀 때, 특정 지점(장애물)을 지날 수 없는 경우입니다.

- **점화식:**
  $$ N(x, y) = N(x-1, y) + N(x, y-1) $$
- **제약 조건 (가지치기):**
  만약 $(x, y)$가 장애물이라면, $N(x, y) = 0$으로 처리합니다.
- **해결:**
  장애물 지점의 경로 수를 0으로 설정하고, 9.4장에서 배운 합의 법칙(DP)을 그대로 적용합니다.

### 예제 2: 이웃하지 않는 배열 (Arrangements without Adjacency)

문자 {A, B, C}를 사용하여 길이 4의 문자열을 만들 때, 같은 문자가 연속으로 오지 않는 경우의 수는?

- **재귀 함수 정의:** `count(length, last_char)`
  - `length`: 만들어야 할 남은 문자열의 길이
  - `last_char`: 바로 직전에 사용된 문자
- **점화식:**
  `count(n, prev)`는 `prev`와 다른 모든 문자에 대해 `count(n-1, next_char)`를 호출하여 그 합을 구합니다.
- **계산:**
  - 첫 번째 자리: 3가지 (A, B, C)
  - 두 번째 자리부터: 이전 문자와 다른 2가지만 가능.
  - 총 개수: $3 \times 2 \times 2 \times 2 = 24$

## 4. 코드 구현 (Code Implementation)

Python을 사용하여 **장애물이 있는 경로 세기** 문제를 재귀와 메모이제이션(Memoization)으로 구현합니다. 이는 Top-down 동적 계획법(DP) 방식입니다.

```python
def count_paths_with_obstacles(width, height, obstacles):
    """
    장애물이 있는 격자에서 최단 경로의 수를 재귀적으로 계산합니다.
    (0, 0)에서 (width, height)까지의 경로.
    """
    memo = {} # 메모이제이션을 위한 딕셔너리

    def solve(x, y):
        # 기저 사례 1: 범위를 벗어나거나 장애물에 닿으면 0
        if x < 0 or y < 0 or (x, y) in obstacles:
            return 0

        # 기저 사례 2: 시작점에 도달하면 1
        if x == 0 and y == 0:
            return 1

        # 메모 확인
        if (x, y) in memo:
            return memo[(x, y)]

        # 재귀 단계: 왼쪽에서 오는 경우 + 아래쪽에서 오는 경우
        result = solve(x - 1, y) + solve(x, y - 1)

        # 결과 저장 및 반환
        memo[(x, y)] = result
        return result

    return solve(width, height)

# 테스트: 3x2 격자, 장애물 없음
print(f"3x2 Paths (no obstacles): {count_paths_with_obstacles(3, 2, set())}") # Expected: 10

# 테스트: 3x3 격자, (1,1) 교차점이 장애물
obstacles = {(1, 1)}
print(f"3x3 Paths with obstacle at (1,1): {count_paths_with_obstacles(3, 3, obstacles)}") # Expected: 12
```

## 5. 요약 (Summary)

- **재귀와 제약:** 재귀는 제약 조건을 각 단계에서 확인하는 방식으로 자연스럽게 통합할 수 있습니다.
- **상태 정의:** 문제의 제약 조건을 재귀 함수의 매개변수로 어떻게 표현할지가 핵심입니다.
- **효율성:** 제약 조건이 있는 재귀는 중복 계산이 많아질 수 있으므로, 메모이제이션(Memoization)을 사용하여 성능을 최적화하는 것이 매우 중요합니다.
