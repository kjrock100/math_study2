# 10.4 실전 문제 (Practice Problems)

## 1. 개요 (Overview)

이 장에서는 10.1장부터 10.3장까지 다룬 재귀(Recursion)의 개념을 종합하여 다양한 실전 문제를 해결합니다. 계단 오르기, 타일링, 확률 점화식 등 점화식을 세워 해결하는 대표적인 문제 유형들을 통해 재귀적 사고방식을 완성합니다.

## 2. 주요 문제 유형 (Key Problem Types)

1.  **계단 오르기 (Climbing Stairs):** 한 번에 오를 수 있는 계단 수가 정해져 있을 때, $n$번째 계단까지 오르는 방법의 수.
2.  **타일링 (Tiling):** 주어진 크기의 바닥을 특정 모양의 타일로 채우는 방법의 수.
3.  **확률 점화식 (Probability Recursion):** 반복 시행에서 특정 상태에 도달할 확률을 이전 상태의 확률로 표현하는 문제.
4.  **하노이의 탑 (Tower of Hanoi):** 재귀의 고전적인 예시로, 원판을 옮기는 최소 횟수 구하기.

## 3. 예제 문제 및 풀이 (Sample Problems & Solutions)

### 문제 1: 계단 오르기 (1, 2, 3계단)

한 번에 1, 2, 또는 3계단을 오를 수 있을 때, 4번째 계단까지 오르는 방법의 수는?

- **점화식:** $S_n = S_{n-1} + S_{n-2} + S_{n-3}$
- **기저 사례:**
  - $S_1 = 1$ (1)
  - $S_2 = 2$ (1+1, 2)
  - $S_3 = 4$ (1+1+1, 1+2, 2+1, 3)
- **계산:**
  - $S_4 = S_3 + S_2 + S_1 = 4 + 2 + 1 = 7$

### 문제 2: $2 \times n$ 타일링 ($1 \times 2$ 타일)

$2 \times n$ 크기의 바닥을 $1 \times 2$ 도미노 타일로 채우는 방법의 수는?

- **점화식:** $T_n = T_{n-1} + T_{n-2}$ (피보나치 수열)
- **원리:**
  - $n$번째 줄을 채우려면, $(n-1)$번째 줄까지 채운 상태에서 세로 타일 하나를 놓거나,
  - $(n-2)$번째 줄까지 채운 상태에서 가로 타일 두 개를 놓아야 합니다.
- **기저 사례:**
  - $T_1 = 1$ (세로 타일 1개)
  - $T_2 = 2$ (세로 2개 또는 가로 2개)
- **계산 ($n=4$):**
  - $T_3 = T_2 + T_1 = 2 + 1 = 3$
  - $T_4 = T_3 + T_2 = 3 + 2 = 5$

### 문제 3: 하노이의 탑 (Tower of Hanoi)

원판 3개를 한 기둥에서 다른 기둥으로 옮기는 최소 횟수는?

- **점화식:** $H_n = 2H_{n-1} + 1$
- **원리:**
  1.  $n-1$개의 원판을 중간 기둥으로 옮긴다 ($H_{n-1}$).
  2.  가장 큰 원판을 목표 기둥으로 옮긴다 (1).
  3.  $n-1$개의 원판을 목표 기둥으로 옮긴다 ($H_{n-1}$).
- **기저 사례:** $H_1 = 1$
- **계산 ($n=3$):**
  - $H_2 = 2H_1 + 1 = 2(1) + 1 = 3$
  - $H_3 = 2H_2 + 1 = 2(3) + 1 = 7$
- **일반항:** $H_n = 2^n - 1$

## 4. 코드 구현 (Code Implementation)

Python을 사용하여 위 문제들을 동적 계획법(DP)으로 효율적으로 해결하는 코드입니다.

```python
def solve_stairs(n):
    if n <= 1: return 1
    if n == 2: return 2
    dp = [0] * (n + 1)
    dp[0], dp[1], dp[2] = 1, 1, 2 # S0=1(가만히 있는 경우)로 두면 점화식이 더 깔끔해짐
    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
    return dp[n]

def solve_tiling(n):
    if n <= 1: return 1
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]

def solve_hanoi(n):
    return 2**n - 1

print(f"계단 오르기 (n=4): {solve_stairs(4)}") # Expected: 7
print(f"타일링 (n=4): {solve_tiling(4)}")     # Expected: 5
print(f"하노이의 탑 (n=3): {solve_hanoi(3)}") # Expected: 7
```

## 5. 요약 (Summary)

- **점화식 찾기:** $n$번째 상태가 되기 직전의 상황들을 모두 고려하여 관계식을 세웁니다.
- **기저 사례 정의:** 점화식이 적용되지 않는 가장 작은 $n$에 대한 값을 직접 구합니다.
- **DP 활용:** 재귀는 개념 이해에 좋지만, 실제 계산은 반복문과 배열(DP 테이블)을 사용하는 것이 훨씬 효율적입니다.
