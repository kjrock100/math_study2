# 20.4 연립 합동식 (Multiple Modular Congruences)

## 1. 개요 (Overview)

이 장에서는 $x \equiv a \pmod m$과 $x \equiv b \pmod n$ 처럼 두 개 이상의 합동식 조건을 동시에 만족하는 미지수 $x$를 찾는 방법을 다룹니다. 이는 고전적인 "중국인의 나머지 정리(Chinese Remainder Theorem, CRT)"의 기초가 되는 내용으로, AMC 8 수준에서는 **대입법**이나 **목록 나열법**을 통해 해결하는 경우가 많습니다.

## 2. 해결 전략 (Solving Strategies)

### 2.1 목록 나열법 (Listing Method)

작은 수에 대해서는 각 조건을 만족하는 수들을 나열하여 공통된 수를 찾습니다.

- 조건: $x \equiv 2 \pmod 3$, $x \equiv 3 \pmod 5$.
- Mod 3: $2, 5, 8, 11, 14, 17, 20, 23 \dots$
- Mod 5: $3, 8, 13, 18, 23 \dots$
- 공통: $8, 23 \dots$
- 일반해: $x \equiv 8 \pmod{15}$. (15는 3과 5의 최소공배수)

### 2.2 대입법 (Substitution Method)

하나의 합동식을 등식으로 변환하여 다른 합동식에 대입하는 방법입니다. 가장 일반적이고 강력한 방법입니다.

1.  첫 번째 식 $x \equiv a \pmod m$을 $x = mk + a$ 꼴로 씁니다.
2.  이를 두 번째 식 $x \equiv b \pmod n$에 대입합니다.
3.  $mk + a \equiv b \pmod n$을 풀어 $k$를 구합니다.
4.  구한 $k$를 다시 원래 식에 대입하여 $x$를 찾습니다.

## 3. 중국인의 나머지 정리 (Chinese Remainder Theorem)

두 법 $m, n$이 **서로소(Coprime)**라면, 연립 합동식의 해는 $m \times n$을 법으로 하여 **유일하게 존재**합니다.
만약 서로소가 아니라면 해가 없거나, $LCM(m, n)$을 법으로 하여 해가 존재합니다.

## 4. 예제 (Examples)

### 예제 1: 기본 연립 합동식

다음 조건을 만족하는 가장 작은 양의 정수 $x$는?

$$
\begin{cases}
x \equiv 1 \pmod 4 \\
x \equiv 2 \pmod 3
\end{cases}
$$

**풀이 (대입법):**

1.  첫 번째 식에서 $x = 4k + 1$.
2.  두 번째 식에 대입: $4k + 1 \equiv 2 \pmod 3$.
3.  $4k \equiv 1 \pmod 3$.
4.  $4 \equiv 1 \pmod 3$이므로, $1 \cdot k \equiv 1 \pmod 3 \implies k \equiv 1 \pmod 3$.
5.  $k$의 최소 양의 정수는 1.
6.  $x = 4(1) + 1 = 5$.
7.  **검증:** $5 \div 4$ 나머지 1, $5 \div 3$ 나머지 2. (정답)

### 예제 2: 서로소가 아닌 경우

$$
\begin{cases}
x \equiv 1 \pmod 4 \\
x \equiv 1 \pmod 6
\end{cases}
$$

- $x = 4k + 1$.
- $4k + 1 \equiv 1 \pmod 6 \implies 4k \equiv 0 \pmod 6$.
- $k=3$일 때 $12 \equiv 0$으로 성립.
- $x = 4(3) + 1 = 13$.
- 일반해: $x \equiv 1 \pmod{12}$. ($LCM(4, 6) = 12$)

## 5. 코드 구현 (Code Implementation)

Python을 사용하여 두 개의 합동식을 만족하는 해를 찾는 함수입니다. 대입법의 논리를 코드로 구현합니다.

```python
def solve_congruence_pair(a1, m1, a2, m2):
    """
    x = a1 (mod m1)
    x = a2 (mod m2)
    를 만족하는 가장 작은 양의 정수 x를 반환
    """
    # x = m1 * k + a1
    # m1 * k + a1 = a2 (mod m2)
    # m1 * k = (a2 - a1) (mod m2)

    # k를 0부터 m2-1까지 증가시키며 찾음 (Brute force for k)
    # m1과 m2가 서로소라면 반드시 해가 하나 존재함
    for k in range(m2):
        if (m1 * k) % m2 == (a2 - a1) % m2:
            x = m1 * k + a1
            return x

    return None # 해가 없는 경우 (서로소가 아니고 모순될 때)

# 테스트
print(f"x = 1 mod 4, x = 2 mod 3 -> x = {solve_congruence_pair(1, 4, 2, 3)}") # Expected: 5
print(f"x = 2 mod 3, x = 3 mod 5 -> x = {solve_congruence_pair(2, 3, 3, 5)}") # Expected: 8

# 검증
# 8 % 3 = 2 (OK), 8 % 5 = 3 (OK)
```

## 6. 요약 (Summary)

- **대입법:** $x = mk + a$로 놓고 다른 식에 대입하여 푼다.
- **유일성:** 법들이 서로소이면 $LCM$ 범위 내에서 유일한 해를 가진다.
- **활용:** "3명씩 묶으면 2명 남고, 5명씩 묶으면 3명 남는다"와 같은 문제 해결.
