# 20.6 실전 문제 (Practice Problems)

## 1. 개요 (Overview)

이 장에서는 20.1장부터 20.5장까지 학습한 합동식(Modular Arithmetic)의 개념을 종합하여 실전 문제를 해결합니다. **요일 계산**, **일의 자리 수 찾기**, **큰 수의 나머지 연산**, **연립 합동식** 등 AMC 8에서 자주 출제되는 정수론 문제들을 다룹니다.

## 2. 주요 문제 유형 (Key Problem Types)

1.  **달력 문제 (Calendar Problems):** $N$일 후의 요일을 구하는 문제. ($\pmod 7$ 활용)
2.  **일의 자리 수 (Units Digits):** 거듭제곱의 합이나 곱의 일의 자리 수 구하기. ($\pmod{10}$ 및 순환 패턴 활용)
3.  **나머지 연산 (Remainder Arithmetic):** 큰 수를 나눈 나머지 구하기. (지수 법칙 및 페르마의 소정리 활용)
4.  **조건을 만족하는 수 찾기:** 여러 나눗셈 조건을 만족하는 최소의 자연수 찾기. (연립 합동식)

## 3. 예제 문제 및 풀이 (Sample Problems & Solutions)

### 문제 1: 달력 계산

오늘은 월요일이다. $2^{100}$일 후는 무슨 요일인가?

- **전략:** $2^{100} \pmod 7$을 구합니다.
- **패턴:** $2^1 \equiv 2, 2^2 \equiv 4, 2^3 \equiv 1 \pmod 7$. (주기 3)
- **계산:** $100 = 3 \times 33 + 1$. 즉, $100 \equiv 1 \pmod 3$.
- **나머지:** $2^{100} \equiv 2^1 \equiv 2 \pmod 7$.
- **결과:** 월요일 + 2일 = **수요일**.

### 문제 2: 일의 자리 수

$N = 3^{2023} + 4^{2024}$의 일의 자리 수는?

- **3의 거듭제곱:** 주기 4 (3, 9, 7, 1).
  - $2023 \div 4$ 나머지 3 $\rightarrow$ 3번째 수 **7**.
- **4의 거듭제곱:** 주기 2 (4, 6).
  - $2024$는 짝수 $\rightarrow$ **6**.
- **합:** $7 + 6 = 13$.
- **정답:** **3**.

### 문제 3: 연립 합동식

3으로 나누면 2가 남고, 5로 나누면 3이 남는 가장 작은 자연수는?

- $x \equiv 2 \pmod 3$
- $x \equiv 3 \pmod 5$
- **나열법:**
  - Mod 5: 3, 8, 13, 18, 23...
  - Mod 3 확인:
    - $3 \equiv 0$ (X)
    - $8 \equiv 2$ (O)
- **정답:** **8**.

## 4. 코드 구현 (Code Implementation)

Python을 사용하여 위 문제들을 해결하는 함수입니다.

```python
def solve_calendar_problem(current_day_idx, days_elapsed):
    """
    current_day_idx: 0=Mon, 1=Tue, ..., 6=Sun
    days_elapsed: 지난 날짜 수
    """
    days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
    future_idx = (current_day_idx + days_elapsed) % 7
    return days[future_idx]

def get_units_digit_sum(base1, exp1, base2, exp2):
    """
    (base1^exp1 + base2^exp2)의 일의 자리 수
    """
    # pow(base, exp, mod) 함수 사용이 가장 효율적
    u1 = pow(base1, exp1, 10)
    u2 = pow(base2, exp2, 10)
    return (u1 + u2) % 10

def solve_congruence_bruteforce(rem1, mod1, rem2, mod2):
    """
    x = rem1 (mod mod1)
    x = rem2 (mod mod2)
    만족하는 가장 작은 x 찾기
    """
    # mod2의 배수 + rem2를 기준으로 탐색 (조금 더 효율적)
    x = rem2
    while True:
        if x % mod1 == rem1:
            return x
        x += mod2
        if x > mod1 * mod2: # 안전장치 (서로소인 경우 LCM 내에 존재)
            return None

# 테스트
# 문제 1: Monday(0) + 2^100 days
days_elapsed = pow(2, 100, 7) # 2^100 mod 7 계산
print(f"Problem 1 (Calendar): {solve_calendar_problem(0, days_elapsed)}") # Expected: Wed

# 문제 2: 3^2023 + 4^2024 units digit
print(f"Problem 2 (Units Digit): {get_units_digit_sum(3, 2023, 4, 2024)}") # Expected: 3

# 문제 3: x = 2 mod 3, x = 3 mod 5
print(f"Problem 3 (Congruence): {solve_congruence_bruteforce(2, 3, 3, 5)}") # Expected: 8
```

## 5. 요약 (Summary)

- **나머지 연산:** 덧셈, 뺄셈, 곱셈에 대해 닫혀 있으므로 큰 수를 미리 나누어 계산합니다.
- **주기성:** 요일(7), 일의 자리(10), 거듭제곱($\pmod n$) 등 반복되는 패턴을 찾습니다.
- **효율성:** `pow(a, b, m)` 함수를 활용하면 매우 큰 지수도 순식간에 계산할 수 있습니다.
