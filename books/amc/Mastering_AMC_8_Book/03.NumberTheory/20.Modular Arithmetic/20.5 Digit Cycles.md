# 20.5 자릿수 순환 (Digit Cycles)

## 1. 개요 (Overview)

모든 자연수의 거듭제곱 $n^k$의 **일의 자리 수(Units Digit)**는 일정한 주기를 가지고 반복됩니다. 이 성질을 이용하면 $2023^{2024}$와 같이 계산이 불가능해 보이는 큰 수의 마지막 자릿수를 아주 쉽게 구할 수 있습니다. 이는 $n^k \pmod{10}$을 구하는 것과 같습니다.

## 2. 숫자별 순환 패턴 (Patterns by Digit)

0부터 9까지의 숫자는 거듭제곱 시 다음과 같은 주기를 가집니다.

### 2.1 주기가 1인 수 (항상 그대로)

거듭제곱을 해도 일의 자리가 변하지 않습니다.

- **0:** $0, 0, 0 \dots$
- **1:** $1, 1, 1 \dots$
- **5:** $5, 25, 125 \dots \rightarrow 5, 5, 5 \dots$
- **6:** $6, 36, 216 \dots \rightarrow 6, 6, 6 \dots$

### 2.2 주기가 2인 수

두 개의 숫자가 번갈아 나타납니다. 지수가 홀수인지 짝수인지가 중요합니다.

- **4:** $4, 16, 64 \dots \rightarrow \mathbf{4, 6}$
  - 홀수 제곱: 4, 짝수 제곱: 6
- **9:** $9, 81, 729 \dots \rightarrow \mathbf{9, 1}$
  - 홀수 제곱: 9, 짝수 제곱: 1

### 2.3 주기가 4인 수

네 개의 숫자가 순환합니다. 지수를 4로 나눈 나머지를 확인해야 합니다.

- **2:** $\mathbf{2, 4, 8, 6}$
- **3:** $\mathbf{3, 9, 7, 1}$
- **7:** $\mathbf{7, 9, 3, 1}$
- **8:** $\mathbf{8, 4, 2, 6}$

## 3. 문제 해결 전략 (Solving Strategy)

문제: $N^K$의 일의 자리 수는?

1.  **밑(Base)의 일의 자리 확인:** $N$의 일의 자리 수 $d$를 구합니다. ($d = N \pmod{10}$)
2.  **주기(Cycle) 확인:** $d$에 해당하는 주기 길이 $L$을 찾습니다. (1, 2, 또는 4)
3.  **지수(Exponent) 나머지 계산:** 지수 $K$를 주기 $L$로 나눈 나머지 $r$을 구합니다.
    - 만약 나머지가 0이라면, 주기의 **마지막 숫자**가 정답입니다.
4.  **매핑:** 주기의 $r$번째 숫자를 선택합니다.

## 4. 예제 (Examples)

### 예제 1: 주기가 4인 경우

$2023^{2024}$의 일의 자리 수는?

1.  밑의 일의 자리: $3$. (주기: $3, 9, 7, 1$, 길이 $L=4$)
2.  지수 계산: $2024 \div 4 = 506$ 나머지 $0$.
3.  나머지가 0이므로 주기의 4번째(마지막) 숫자인 **1**.

### 예제 2: 주기가 2인 경우

$4^{99}$의 일의 자리 수는?

1.  밑의 일의 자리: $4$. (주기: $4, 6$, 길이 $L=2$)
2.  지수 99는 **홀수**.
3.  홀수 번째 숫자인 **4**.

## 5. 코드 구현 (Code Implementation)

Python을 사용하여 각 숫자의 주기를 생성하고, 이를 이용해 큰 수의 일의 자리를 구하는 함수입니다.

```python
def get_digit_cycle(digit):
    """0~9 사이 숫자의 거듭제곱 일의 자리 주기 반환"""
    cycle = []
    curr = digit
    while curr not in cycle:
        cycle.append(curr)
        curr = (curr * digit) % 10
    return cycle

def solve_units_digit(base, exponent):
    """base^exponent의 일의 자리 수 계산"""
    digit = base % 10
    if exponent == 0: return 1

    cycle = get_digit_cycle(digit)
    cycle_len = len(cycle)

    # 나머지가 0이면 마지막 인덱스(-1)를 사용하기 위해 조정
    # (exponent - 1) % cycle_len 을 하면 0-based index가 됨
    idx = (exponent - 1) % cycle_len
    return cycle[idx]

# 테스트
print("Digit Cycles:")
for d in range(10):
    print(f"{d}: {get_digit_cycle(d)}")

print(f"\nUnits digit of 2023^2024: {solve_units_digit(2023, 2024)}") # Expected: 1
print(f"Units digit of 4^99: {solve_units_digit(4, 99)}")       # Expected: 4
print(f"Units digit of 2^50: {solve_units_digit(2, 50)}")       # Expected: 4
```

## 6. 요약 (Summary)

- **0, 1, 5, 6:** 변하지 않음.
- **4, 9:** 2개씩 반복 (홀/짝).
- **2, 3, 7, 8:** 4개씩 반복 (지수 $\pmod 4$).
