# 18.4 실전 문제 (Practice Problems)

## 1. 개요 (Overview)

이 장에서는 18.1장부터 18.3장까지 학습한 약수(Factors/Divisors)의 개수, 합, 곱에 대한 개념을 종합하여 실전 문제를 해결합니다. 단순히 공식을 적용하는 것을 넘어, **약수의 개수가 주어졌을 때 원래 수를 찾는 역추적(Reverse Engineering)** 문제나, **완전제곱수**와 관련된 심화 유형을 다룹니다.

## 2. 주요 문제 유형 (Key Problem Types)

1.  **역추적 문제 (Reverse Problems):** 약수의 개수가 $k$인 가장 작은 자연수 찾기.
2.  **약수의 곱 응용:** 약수의 곱이 특정 값이 되거나, 완전제곱수가 되는 조건 찾기.
3.  **홀수 개의 약수:** 약수의 개수가 홀수인 수는 완전제곱수라는 성질 활용.
4.  **소인수분해 활용:** 약수의 성질을 이용해 원래 수의 소인수 구조 파악하기.

## 3. 예제 문제 및 풀이 (Sample Problems & Solutions)

### 문제 1: 약수의 개수가 12인 가장 작은 수

약수의 개수가 12개인 가장 작은 자연수는?

- **전략:** 12를 여러 수의 곱으로 분해(인수분해)하여 지수 조합을 만듭니다. 지수가 클수록 작은 소수(2, 3, 5...)에 배정해야 합니다.
- **가능한 조합 (지수 = 인수 - 1):**
  1.  $12$ (지수 11): $2^{11} = 2048$
  2.  $6 \times 2$ (지수 5, 1): $2^5 \times 3^1 = 32 \times 3 = 96$
  3.  $4 \times 3$ (지수 3, 2): $2^3 \times 3^2 = 8 \times 9 = 72$
  4.  $3 \times 2 \times 2$ (지수 2, 1, 1): $2^2 \times 3^1 \times 5^1 = 4 \times 3 \times 5 = 60$
- **비교:** $60 < 72 < 96 < 2048$.
- **정답:** 60.

### 문제 2: 약수의 곱 계산

$N = 100$의 모든 양의 약수의 곱은?

- **약수의 개수:** $100 = 10^2 = 2^2 \times 5^2$.
  - $d(100) = (2+1)(2+1) = 9$.
- **공식 적용:** $P(100) = 100^{9/2} = (10^2)^{4.5} = 10^9$.
- **정답:** $10^9$ (또는 1,000,000,000).

### 문제 3: 약수의 개수가 홀수인 수

1부터 50까지의 자연수 중 약수의 개수가 홀수인 수는 몇 개인가?

- **원리:** 약수의 개수가 홀수 $\iff$ 완전제곱수.
- **나열:** $1^2=1, 2^2=4, 3^2=9, 4^2=16, 5^2=25, 6^2=36, 7^2=49$.
- **정답:** 7개.

## 4. 코드 구현 (Code Implementation)

Python을 사용하여 약수의 개수가 $k$인 가장 작은 수를 찾는 알고리즘과 약수의 곱을 계산하는 함수입니다.

```python
from functools import reduce

def get_smallest_with_n_divisors(target_divisors):
    """
    약수의 개수가 target_divisors인 가장 작은 자연수를 찾는 함수
    """
    if target_divisors == 1:
        return 1

    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53] # 충분한 소수 리스트
    min_num = float('inf')

    def find_combinations(current_target, index, current_val, limit_exponent):
        nonlocal min_num

        # 가지치기: 이미 찾은 최소값보다 커지면 중단
        if current_val >= min_num:
            return

        # 약수 개수 조건을 만족했을 때
        if current_target == 1:
            min_num = min(min_num, current_val)
            return

        # current_target의 약수 d에 대해 (d-1)을 지수로 사용
        # 단, 지수는 내림차순이어야 최소가 됨 (limit_exponent로 제어)
        for d in range(current_target, 1, -1):
            if current_target % d == 0:
                exponent = d - 1
                if exponent > limit_exponent:
                    continue

                # 다음 단계 값 계산
                next_val = current_val * (primes[index] ** exponent)
                find_combinations(current_target // d, index + 1, next_val, exponent)

    # 초기 호출: limit_exponent는 무한대
    find_combinations(target_divisors, 0, 1, 100)
    return min_num

def calculate_product_of_factors(n):
    # 약수의 개수 구하기
    count = 0
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            count += 1
            if i * i != n:
                count += 1

    # 공식: n^(count/2)
    # 부동소수점 이슈 방지를 위해 정수 연산 처리
    if count % 2 == 0:
        return n ** (count // 2)
    else:
        return int(n**0.5) ** count

# 테스트
print(f"Smallest number with 12 divisors: {get_smallest_with_n_divisors(12)}") # Expected: 60
print(f"Product of factors of 100: {calculate_product_of_factors(100)}") # Expected: 10^9
```

## 5. 요약 (Summary)

- **역추적:** 약수의 개수 $N$을 인수분해하여 가능한 지수 조합($e_i = d_i - 1$)을 만들고, 작은 소수에 큰 지수를 할당하여 비교합니다.
- **약수의 곱:** $N^{d(N)/2}$. 완전제곱수일 때는 $(\sqrt{N})^{d(N)}$이 됩니다.
- **완전제곱수:** 약수의 개수가 홀수인 유일한 경우입니다.
