# 22.2 화폐 문제 (Money Problems)

## 1. 개요 (Overview)

화폐 문제(Money Problems)는 정해진 가치를 가진 동전들(Coins)을 조합하여 특정 금액을 만들거나, 동전의 개수를 최소화하는 문제입니다. 이는 정수론의 **부정방정식(Diophantine Equations)**과 **조합론(Combinatorics)**이 결합된 실용적인 유형입니다.

## 2. 주요 개념 (Key Concepts)

### 2.1 미국의 동전 단위 (US Coin Denominations)

AMC 8 문제에서는 주로 미국의 동전 단위를 사용합니다.

- **Penny (P):** 1 cent
- **Nickel (N):** 5 cents
- **Dime (D):** 10 cents
- **Quarter (Q):** 25 cents

### 2.2 가치 방정식 (Value Equation)

총 금액 $V$를 만들기 위해 각 동전을 $p, n, d, q$개 사용한다면 다음과 같은 식이 성립합니다.
$$ V = 1p + 5n + 10d + 25q $$
(단, $p, n, d, q$는 음이 아닌 정수)

## 3. 문제 해결 전략 (Strategies)

### 3.1 최소 개수 구하기 (Greedy Approach)

동전의 개수를 가장 적게 사용하여 금액을 만들려면, **가치가 큰 동전부터** 최대한 많이 사용해야 합니다.

- 예: 87센트 만들기
  1.  Quarter(25): $87 \div 25 = 3$개, 나머지 12.
  2.  Dime(10): $12 \div 10 = 1$개, 나머지 2.
  3.  Nickel(5): $2 \div 5 = 0$개, 나머지 2.
  4.  Penny(1): 2개.
  - 총: $3+1+0+2 = 6$개.

### 3.2 경우의 수 세기 (Counting Combinations)

특정 금액을 만드는 모든 방법의 수를 구할 때는 **가치가 큰 동전을 기준**으로 경우(Case)를 나누는 것이 효율적입니다.

- 예: 15센트 만들기 (Nickel, Dime, Penny 사용)
  - Case 1: Dime 1개 사용 ($15 - 10 = 5$ 남음)
    - Nickel 1개 (1D, 1N)
    - Penny 5개 (1D, 5P)
    - $\rightarrow$ 2가지.
  - Case 2: Dime 0개 사용 ($15$ 남음)
    - Nickel 3개 (3N)
    - Nickel 2개 (2N, 5P)
    - Nickel 1개 (1N, 10P)
    - Nickel 0개 (15P)
    - $\rightarrow$ 4가지.
  - 총합: $2 + 4 = 6$가지.

## 4. 예제 (Examples)

### 예제 1: 동전 개수

Mike는 4개의 Quarter, 3개의 Dime, 2개의 Nickel을 가지고 있다. 그가 만들 수 **없는** 가장 작은 금액(센트 단위)은? (단, 1센트짜리는 없음)

- 가능한 단위: 5, 10, 25. (모두 5의 배수이므로 5의 배수가 아닌 수는 못 만듦. 문제 의도가 5의 배수 중 못 만드는 것을 묻는다면?)
- 만들 수 있는 합: 5, 10, 15(10+5), 20(10+10), 25, 30...
- Dime과 Nickel로 만들 수 있는 최대: $30 + 10 = 40$.
- 따라서 45는 Quarter 없이는 불가능, Quarter 1개 쓰면 $25 + 20 = 45$ 가능.
- 이런 식으로 조합을 확인해야 함. (이 문제는 보통 Penny가 없다는 점이 핵심)

### 예제 2: 환전 문제

1달러(100센트)를 Quarter, Dime, Nickel로 바꾸는 방법의 수는?

- $25q + 10d + 5n = 100 \implies 5q + 2d + n = 20$.
- $q$를 기준으로 분류:
  - $q=4$: $2d+n=0 \rightarrow (0,0)$ (1가지)
  - $q=3$: $2d+n=5 \rightarrow d=0,1,2$ (3가지)
  - $q=2$: $2d+n=10 \rightarrow d=0 \dots 5$ (6가지)
  - $q=1$: $2d+n=15 \rightarrow d=0 \dots 7$ (8가지)
  - $q=0$: $2d+n=20 \rightarrow d=0 \dots 10$ (11가지)
- 총합: $1+3+6+8+11 = 29$가지.

## 5. 코드 구현 (Code Implementation)

Python을 사용하여 최소 동전 개수를 구하는 그리디 알고리즘과, 동전 교환 방법의 수를 구하는 동적 계획법(Dynamic Programming) 코드입니다.

```python
def min_coins_greedy(cents):
    """가장 적은 동전으로 금액을 만드는 방법 (Greedy)"""
    coins = [25, 10, 5, 1]
    coin_names = ["Quarter", "Dime", "Nickel", "Penny"]
    result = {}

    remaining = cents
    for coin, name in zip(coins, coin_names):
        count = remaining // coin
        if count > 0:
            result[name] = count
            remaining %= coin

    return result

def count_ways_to_make_change(target, coins):
    """특정 금액을 만드는 모든 방법의 수 (Dynamic Programming)"""
    # dp[i] = i센트를 만드는 방법의 수
    dp = [0] * (target + 1)
    dp[0] = 1  # 0원을 만드는 방법은 1가지 (아무것도 안 냄)

    for coin in coins:
        for i in range(coin, target + 1):
            dp[i] += dp[i - coin]

    return dp[target]

# 테스트
print(f"Min coins for 87 cents: {min_coins_greedy(87)}")
# Expected: {'Quarter': 3, 'Dime': 1, 'Penny': 2}

ways_100 = count_ways_to_make_change(100, [25, 10, 5])
print(f"Ways to make $1 with Q, D, N: {ways_100}")
# Expected: 29
```

## 6. 요약 (Summary)

- **최소 개수:** 큰 단위 동전부터 채운다 (Greedy).
- **경우의 수:** 가장 큰 동전의 개수를 기준으로 케이스를 분류(Case Work)하거나, DP 알고리즘을 활용한다.
- **부정방정식:** $25q + 10d + 5n + p = \text{Total}$ 식을 세우고 정수 조건을 활용한다.
