# 22.4 치킨 맥너겟 정리 (Chicken McNugget Theorem)

## 1. 개요 (Overview)

치킨 맥너겟 정리(Chicken McNugget Theorem)는 정수론의 '프로베니우스 동전 문제(Frobenius Coin Problem)'의 특수한 경우입니다. 과거 맥도날드에서 맥너겟을 9개, 20개 단위로 팔았을 때, 살 수 없는 가장 큰 맥너겟의 개수가 무엇인지 묻는 것에서 유래했습니다.

## 2. 정리 및 공식 (Theorem & Formula)

### 2.1 최대 불가능한 수 (Largest Impossible Number)

서로소(Coprime)인 두 양의 정수 $m, n$에 대하여, $am + bn$ ($a, b \ge 0$인 정수) 꼴로 나타낼 수 **없는** 가장 큰 정수는 다음과 같습니다.

$$ mn - m - n $$

### 2.2 불가능한 수의 개수 (Count of Impossible Numbers)

나타낼 수 없는 양의 정수의 총 개수는 다음과 같습니다.

$$ \frac{(m-1)(n-1)}{2} $$

## 3. 조건 (Conditions)

- $m$과 $n$은 반드시 **서로소(Relatively Prime)**여야 합니다. 즉, $GCD(m, n) = 1$.
- 만약 $GCD(m, n) = d > 1$이라면, $d$의 배수가 아닌 수는 영원히 만들 수 없으므로, 만들 수 없는 가장 큰 수는 존재하지 않습니다(무한대).

## 4. 예제 (Examples)

### 예제 1: 3개, 5개 포장

3개들이와 5개들이 포장으로 물건을 팔 때, 살 수 없는 가장 큰 개수는?

- $m=3, n=5$. (서로소 확인: $GCD(3, 5)=1$)
- 공식: $3 \times 5 - 3 - 5 = 15 - 8 = 7$.
- **검증:**
  - 불가능: 1, 2, 4, 7.
  - 가능: 3, 5, 6(3+3), 8(3+5), 9(3+3+3), 10(5+5)...
- **정답:** 7.
- **불가능한 수의 개수:** $\frac{(3-1)(5-1)}{2} = \frac{2 \times 4}{2} = 4$개. (1, 2, 4, 7 맞음)

### 예제 2: 5개, 7개 포장

- $m=5, n=7$.
- 최대 불가능 수: $5 \times 7 - 5 - 7 = 35 - 12 = 23$.
- 개수: $\frac{4 \times 6}{2} = 12$개.

## 5. 코드 구현 (Code Implementation)

Python을 사용하여 맥너겟 정리의 값을 계산하고, 실제로 불가능한 수들을 나열하여 검증하는 함수입니다.

```python
import math

def chicken_mcnugget_theorem(m, n):
    """
    m, n이 서로소일 때, 만들 수 없는 가장 큰 수와 그 개수를 반환
    """
    if math.gcd(m, n) != 1:
        return None, None # 서로소가 아니면 정의되지 않음 (무한)

    largest_impossible = m * n - m - n
    count_impossible = (m - 1) * (n - 1) // 2

    return largest_impossible, count_impossible

def find_unrepresentable_numbers(m, n):
    """
    실제로 만들 수 없는 수들을 브루트 포스로 찾아서 반환 (검증용)
    """
    if math.gcd(m, n) != 1:
        return []

    limit = m * n # 이 값 이후로는 모두 만들 수 있음이 보장됨
    representable = [False] * (limit + 1)
    representable[0] = True # 0은 0개씩 사면 됨

    for i in range(limit + 1):
        if representable[i]:
            if i + m <= limit:
                representable[i + m] = True
            if i + n <= limit:
                representable[i + n] = True

    unrepresentable = [i for i in range(limit + 1) if not representable[i]]
    return unrepresentable

# 테스트
m, n = 6, 9
print(f"Case ({m}, {n}): GCD is {math.gcd(m, n)}. Theorem applicable? {math.gcd(m, n) == 1}")

m, n = 3, 5
largest, count = chicken_mcnugget_theorem(m, n)
actual_list = find_unrepresentable_numbers(m, n)
print(f"Case ({m}, {n}): Largest Impossible = {largest}, Count = {count}")
print(f"Actual Impossible Numbers: {actual_list}")
# Expected: Largest=7, Count=4, List=[1, 2, 4, 7]

m, n = 6, 7
largest, count = chicken_mcnugget_theorem(m, n)
print(f"Case ({m}, {n}): Largest Impossible = {largest}, Count = {count}")
# Expected: Largest=29, Count=15
```

## 6. 요약 (Summary)

- **공식:** $mn - m - n$.
- **개수:** $\frac{(m-1)(n-1)}{2}$.
- **조건:** 두 수는 서로소여야 한다.
