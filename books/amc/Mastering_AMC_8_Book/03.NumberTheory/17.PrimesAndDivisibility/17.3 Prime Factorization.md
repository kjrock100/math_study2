# 17.3 소인수분해 (Prime Factorization)

## 1. 개요 (Overview)

소인수분해(Prime Factorization)는 1보다 큰 자연수를 소수(Prime Number)들의 곱으로만 나타내는 것입니다. 산술의 기본 정리(Fundamental Theorem of Arithmetic)에 의해, 곱하는 순서를 제외하면 이 표현은 **유일**합니다. AMC 8에서 약수의 성질, 최대공약수/최소공배수, 완전제곱수 판별 등 수많은 정수론 문제의 기초가 됩니다.

## 2. 방법 (Methods)

### 2.1 가지치기 (Factor Tree)

수를 두 수의 곱으로 분해하고, 그 수들을 다시 분해하는 과정을 소수만 남을 때까지 반복합니다. 시각적으로 이해하기 쉽습니다.

### 2.2 나눗셈법 (Repeated Division)

가장 작은 소수(2, 3, 5...)부터 차례대로 나누어 몫이 소수가 될 때까지 반복합니다. 체계적인 계산에 유리합니다.

## 3. 주요 응용 (Key Applications)

자연수 $N$을 소인수분해하여 $N = p_1^{e_1} \times p_2^{e_2} \times \dots \times p_k^{e_k}$ 꼴로 나타냈을 때:

### 3.1 약수의 개수 (Number of Divisors)

각 소인수의 지수에 1을 더하여 모두 곱합니다.
$$ d(N) = (e_1 + 1)(e_2 + 1)\dots(e_k + 1) $$

- **원리:** 각 소인수 $p_i$를 $0$개부터 $e_i$개까지 선택할 수 있는 경우의 수의 곱입니다.

### 3.2 약수의 합 (Sum of Divisors)

각 소인수별로 등비수열의 합 공식을 적용하여 곱합니다.
$$ \sigma(N) = \left(\frac{p_1^{e_1+1}-1}{p_1-1}\right) \times \dots \times \left(\frac{p_k^{e_k+1}-1}{p_k-1}\right) $$

### 3.3 완전제곱수 만들기 (Perfect Squares)

어떤 수 $N$이 완전제곱수가 되려면, 소인수분해했을 때 **모든 소인수의 지수가 짝수**여야 합니다.

- 예: $12 = 2^2 \times 3^1$. 완전제곱수가 되려면 최소한 $3$을 곱해야 함 ($2^2 \times 3^2 = 36 = 6^2$).

## 4. 예제 (Examples)

### 예제 1: 소인수분해

$360$을 소인수분해하시오.

- $360 = 36 \times 10 = (6^2) \times (2 \times 5) = (2 \times 3)^2 \times 2 \times 5$
- 정리: $2^2 \times 3^2 \times 2^1 \times 5^1 = 2^3 \times 3^2 \times 5^1$.

### 예제 2: 약수의 개수와 합

$360$의 약수의 개수는?

- 지수: 3, 2, 1.
- 개수: $(3+1)(2+1)(1+1) = 4 \times 3 \times 2 = 24$개.

### 예제 3: 완전제곱수 만들기

$n \times 360$이 완전제곱수가 되도록 하는 가장 작은 자연수 $n$은?

- $360 = 2^3 \times 3^2 \times 5^1$.
- 지수가 홀수인 소인수는 $2$($e=3$)와 $5$($e=1$)입니다.
- 지수를 짝수로 만들기 위해 $2$ 하나와 $5$ 하나가 더 필요합니다.
- **정답:** $n = 2 \times 5 = 10$.

## 5. 코드 구현 (Code Implementation)

Python을 사용하여 소인수분해를 수행하고, 이를 바탕으로 약수의 개수와 합을 계산하는 함수입니다.

```python
def get_prime_factorization(n):
    """소인수분해 결과를 딕셔너리로 반환 {소인수: 지수}"""
    factors = {}
    d = 2
    temp = n
    while d * d <= temp:
        while temp % d == 0:
            factors[d] = factors.get(d, 0) + 1
            temp //= d
        d += 1
    if temp > 1:
        factors[temp] = factors.get(temp, 0) + 1
    return factors

def analyze_divisors(n):
    """약수의 개수와 합 계산"""
    factors = get_prime_factorization(n)
    count = 1
    total_sum = 1

    for p, exponent in factors.items():
        # 개수: (지수 + 1)들의 곱
        count *= (exponent + 1)

        # 합: (p^(e+1) - 1) / (p - 1)
        term_sum = (p**(exponent + 1) - 1) // (p - 1)
        total_sum *= term_sum

    return count, total_sum

# 테스트
num = 360
factors = get_prime_factorization(num)
d_count, d_sum = analyze_divisors(num)

print(f"Number: {num}")
print(f"Prime Factors: {factors}")       # Expected: {2: 3, 3: 2, 5: 1}
print(f"Divisor Count: {d_count}")       # Expected: 24
print(f"Divisor Sum: {d_sum}")           # Expected: (15)*(13)*(6) = 1170
```

## 6. 요약 (Summary)

- **소인수분해:** $N = p_1^{e_1} \dots p_k^{e_k}$.
- **약수 개수:** 지수에 1 더해서 곱한다.
- **완전제곱수:** 모든 지수가 짝수여야 한다.
