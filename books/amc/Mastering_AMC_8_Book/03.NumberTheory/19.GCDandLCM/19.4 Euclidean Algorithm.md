# 19.4 유클리드 호제법 (Euclidean Algorithm)

## 1. 개요 (Overview)

유클리드 호제법(Euclidean Algorithm)은 두 자연수의 최대공약수(GCD)를 구하는 가장 효율적인 알고리즘입니다. 소인수분해가 어려운 큰 수의 GCD를 구할 때 매우 강력하며, 그 원리를 확장하면 $ax + by = GCD(a, b)$ 형태의 부정방정식(Diophantine Equation)의 해를 찾는 데도 사용됩니다.

## 2. 기본 원리 (Basic Principle)

두 자연수 $a, b$ ($a > b$)에 대하여, $a$와 $b$의 최대공약수는 $b$와 $a$를 $b$로 나눈 나머지($r$)의 최대공약수와 같습니다.

$$ GCD(a, b) = GCD(b, a \pmod b) $$

이 과정을 나머지가 0이 될 때까지 반복하면, 마지막에 0이 아닌 나머지가 바로 최대공약수입니다.

### 2.1 원리 증명

1.  $a = bq + r$ (단, $0 \le r < b$)
2.  $a$와 $b$의 공약수를 $d$라고 하면, $a$와 $b$는 $d$로 나누어 떨어집니다.
3.  $r = a - bq$ 이므로, $r$도 $d$로 나누어 떨어집니다. 즉, $d$는 $b$와 $r$의 공약수입니다.
4.  역으로, $b$와 $r$의 공약수를 $d'$라고 하면, $a = bq + r$이므로 $a$도 $d'$로 나누어 떨어집니다. 즉, $d'$는 $a$와 $b$의 공약수입니다.
5.  결론적으로, $(a, b)$의 공약수 집합과 $(b, r)$의 공약수 집합이 같으므로, 최대공약수도 같습니다.

## 3. 확장 유클리드 호제법 (Extended Euclidean Algorithm)

유클리드 호제법을 거꾸로 거슬러 올라가면, $ax + by = GCD(a, b)$를 만족하는 정수 해 $(x, y)$를 찾을 수 있습니다.

- **베주 항등식(Bézout's Identity):** $GCD(a, b)$는 $ax + by$ 형태로 표현 가능한 가장 작은 양의 정수입니다.

## 4. 예제 (Examples)

### 예제 1: GCD 계산

$GCD(48, 18)$을 구하시오.

1.  $GCD(48, 18) = GCD(18, 48 \pmod{18}) = GCD(18, 12)$
2.  $GCD(18, 12) = GCD(12, 18 \pmod{12}) = GCD(12, 6)$
3.  $GCD(12, 6) = GCD(6, 12 \pmod 6) = GCD(6, 0)$
4.  나머지가 0이므로, 최대공약수는 **6**.

### 예제 2: 확장 유클리드 호제법

$48x + 18y = 6$의 정수 해 $(x, y)$를 하나 찾으시오.

1.  $48 = 2 \cdot 18 + 12 \implies 12 = 48 - 2 \cdot 18$
2.  $18 = 1 \cdot 12 + 6 \implies 6 = 18 - 1 \cdot 12$
3.  $6 = 18 - 1 \cdot (48 - 2 \cdot 18)$
4.  $6 = 18 - 48 + 2 \cdot 18 = 3 \cdot 18 - 1 \cdot 48$
5.  **해:** $x = -1, y = 3$.

## 5. 코드 구현 (Code Implementation)

Python을 사용하여 유클리드 호제법과 확장 유클리드 호제법을 구현하는 함수입니다.

```python
def gcd(a, b):
    """
    유클리드 호제법으로 GCD 계산 (반복문)
    """
    while b:
        a, b = b, a % b
    return a

def extended_gcd(a, b):
    """
    확장 유클리드 호제법
    ax + by = gcd(a, b)를 만족하는 (gcd, x, y)를 반환
    """
    if a == 0:
        return b, 0, 1

    # 재귀 호출
    g, x1, y1 = extended_gcd(b % a, a)

    # 결과 업데이트
    x = y1 - (b // a) * x1
    y = x1

    return g, x, y

# 테스트
a, b = 48, 18

# GCD
gcd_val = gcd(a, b)
print(f"GCD({a}, {b}) = {gcd_val}") # Expected: 6

# Extended GCD
g, x, y = extended_gcd(a, b)
print(f"Extended GCD: g={g}, x={x}, y={y}") # Expected: g=6, x=-1, y=3
print(f"Verification: {a}*({x}) + {b}*({y}) = {a*x + b*y}")
```

## 6. 요약 (Summary)

- **기본 원리:** $GCD(a, b) = GCD(b, a \pmod b)$.
- **효율성:** 소인수분해보다 훨씬 빠르게 큰 수의 GCD를 계산할 수 있습니다.
- **확장:** $ax+by=GCD(a,b)$ 형태의 부정방정식의 해를 찾는 데 사용됩니다.
