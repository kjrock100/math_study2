# 10.3 확률 점화식 (Probability Recursions)

## 1. 개요 (Overview)

확률 점화식은 어떤 시행을 반복할 때, $n$번째 시행에서 특정 사건이 일어날 확률($P_n$)을 이전 단계의 확률($P_{n-1}, P_{n-2}, \dots$)을 이용하여 나타내는 방법입니다. 이는 경우의 수를 세는 재귀 문제와 유사하지만, 각 단계가 확률 값으로 표현된다는 차이가 있습니다.

## 2. 핵심 전략 (Key Strategy)

### 2.1 상태 정의 (Define States)

문제 상황을 몇 개의 명확한 **상태(State)**로 나눕니다.

- 예: 동전 던지기에서 "앞면이 연속으로 나온 상태", "뒷면이 나온 상태" 등.

### 2.2 상태 전이도 (State Transition Diagram)

각 상태에서 다른 상태로 어떻게 변하는지 화살표와 확률로 나타냅니다. 이는 점화식을 세우는 데 매우 유용합니다.

### 2.3 점화식 수립 (Formulate Recurrence)

현재 상태($P_n$)가 되기 위한 **이전 단계의 모든 가능성**을 고려하여 점화식을 만듭니다.

$$ P_n = (\text{상태 A에서 올 확률}) \times P(\text{상태 A}) + (\text{상태 B에서 올 확률}) \times P(\text{상태 B}) + \dots $$

## 3. 예제 (Example)

### 예제 1: 연속으로 앞면이 나올 확률

공정한 동전을 던져 **처음으로 앞면(H)이 두 번 연속**으로 나오면 멈춘다. $n$번째 시행에서 게임이 끝날 확률 $P_n$은?

- **상태 분석:**

  - $S_0$: 시작 상태 (아무것도 안 던짐)
  - $S_1$: 마지막이 뒷면(T)인 상태 (연속이 깨짐)
  - $S_2$: 마지막이 앞면(H) 하나인 상태
  - $S_3$: 게임 끝 (HH)

- **점화식 수립:**
  $n$번째에 게임이 끝나려면($P_n$), $(n-1)$번째는 반드시 **마지막이 H 하나인 상태**여야 하고, $n$번째에 H가 나와야 합니다.

  - $(n-1)$번째가 '마지막이 H 하나인 상태'가 되려면, $(n-2)$번째는 '마지막이 T인 상태' 또는 '시작 상태'여야 하고, $(n-1)$번째에 H가 나와야 합니다.
  - $P_n$: $n$번째에 끝날 확률.
  - $n$번째에 HH가 나오려면, $(n-1)$번째는 T...H 상태여야 한다.
  - $(n-1)$번째까지 게임이 끝나지 않았을 확률을 $Q_{n-1}$이라 하자.
  - $P_n = Q_{n-2} \times P(T \to H) \times P(H) = Q_{n-2} \times \frac{1}{2} \times \frac{1}{2}$ (복잡함)

- **더 쉬운 접근 (전체 확률 이용):**
  $P_n$을 $n$번째 시행까지 **게임이 끝났을** 누적 확률이라고 정의하자.
  - $P_n = P_{n-1} + (\text{n-1까지 안 끝나고 n에서 끝날 확률})$
  - $n$에서 끝나려면 `...THH` 형태여야 한다. 즉, $(n-2)$까지 안 끝나고, $(n-1)$에 T, $n$에 H가 나와야 하는가?
  - $n$에서 끝나려면 `...HTH`? `...TTH`?
  - $n$에서 끝나는 경우는 `...THH` 뿐이다. $(n-2)$번째에 T가 나오고, $(n-1)$에 H, $n$에 H가 나와야 한다.
  - $P(\text{n에서 끝남}) = P(\text{n-1까지 안 끝남}) \times P(H) \times P(H)$? 아니다.
  - $A_n$: $n$번째 시행에서 끝날 확률.
  - $A_n$이 되려면 $(n-2)$번째까지 T로 끝나고, $(n-1)$에 H, $n$에 H가 나와야 한다.
  - $P(\text{...T}) = \frac{1}{2}$
  - $A_n = (\frac{1}{2})^{n-2} \times \frac{1}{2} \times \frac{1}{2}$? 아니다.
  - $A_n$: $n$번째에 끝날 확률.
  - $n=2$: HH ($\frac{1}{4}$)
  - $n=3$: THH ($\frac{1}{8}$)
  - $n=4$: HTHH, TTHH? 아니다. HTHH는 2번째에 H가 나왔으므로 안된다. TTHH만 가능. ($\frac{1}{16}$)
  - $A_n = \frac{F_{n-2}}{2^n}$ (단, $F_0=1, F_1=1$인 피보나치 수열)

## 4. 코드 구현 (Code Implementation)

Python을 사용하여 "연속 두 번 앞면" 문제를 시뮬레이션하고, 재귀적으로 확률을 계산합니다.

```python
import random

def simulate_consecutive_heads(n_trials):
    """
    'HH'가 나올 때까지 동전을 던지는 시뮬레이션
    """
    end_times = {}
    for _ in range(n_trials):
        flips = ""
        count = 0
        while True:
            count += 1
            flips += random.choice(['H', 'T'])
            if flips.endswith("HH"):
                end_times[count] = end_times.get(count, 0) + 1
                break

    print(f"--- 시뮬레이션 결과 (총 {n_trials}회) ---")
    for i in sorted(end_times.keys()):
        prob = end_times[i] / n_trials
        print(f"n={i}: 확률 {prob:.4f}")

def calculate_prob_recursion(n, memo=None):
    """
    An = F(n-2) / 2^n 점화식을 이용한 이론 확률 계산
    F_0=1, F_1=1, F_2=2, ... (피보나치 수열)
    """
    if memo is None:
        memo = {0: 1, 1: 1} # F_0, F_1

    def fib(k):
        if k in memo:
            return memo[k]
        memo[k] = fib(k-1) + fib(k-2)
        return memo[k]

    if n < 2:
        return 0

    return fib(n-2) / (2**n)

# 시뮬레이션 실행
simulate_consecutive_heads(100000)

# 이론값 계산
print("\n--- 이론값 계산 ---")
for i in range(2, 8):
    print(f"n={i}: 확률 {calculate_prob_recursion(i):.4f} (분수: {calculate_prob_recursion(i).as_integer_ratio()})")

```

## 5. 요약 (Summary)

- **확률 재귀:** 현재 상태의 확률을 이전 상태들의 확률의 합으로 표현합니다.
- **상태 전이:** 문제의 모든 가능한 상태와 그들 사이의 전환 확률을 파악하는 것이 가장 중요합니다.
- **점화식:** 복잡해 보이지만, 작은 $n$에 대해 직접 값을 구해보고 패턴을 찾으면 점화식을 유추할 수 있습니다.
