# 9.4 경로 세기 (Path Counting)

## 1. 개요 (Overview)

경로 세기(Path Counting)는 격자(Grid) 상의 한 지점(Start)에서 다른 지점(End)까지 가는 **최단 경로(Shortest Path)**의 수를 구하는 문제입니다. 최단 경로란 되돌아가지 않고 목표 지점을 향해 가로(Right)와 세로(Up) 방향으로만 이동하는 것을 의미합니다.

## 2. 해결 방법 1: 합의 법칙 (The Addition Method)

복잡한 격자나 장애물이 있는 경우에 가장 강력하고 안전한 방법입니다. 파스칼의 삼각형 원리와 동일하며, 컴퓨터 과학의 **동적 계획법(Dynamic Programming)** 기초가 됩니다.

### 2.1 원리

특정 교차점(Point)에 도달하는 경로의 수는 **그 점의 바로 이전 단계(왼쪽 점 + 아래쪽 점)의 경로 수의 합**과 같습니다.

$$ N(x, y) = N(x-1, y) + N(x, y-1) $$

### 2.2 절차

1.  출발점에 1을 씁니다.
2.  출발점에서 갈 수 있는 가장자리(테두리)의 교차점들에 모두 1을 씁니다 (외길).
3.  나머지 내부 교차점들은 왼쪽 숫자와 아래쪽 숫자를 더해서 채워 나갑니다.
4.  도착 지점에 적힌 숫자가 정답입니다.

## 3. 해결 방법 2: 조합 공식 (Combinatorial Formula)

장애물이 없는 직사각형 형태의 온전한 격자에서 빠르게 계산할 때 사용합니다.

### 3.1 원리

가로로 $m$칸, 세로로 $n$칸을 이동해야 한다면, 총 이동 횟수는 $m+n$번입니다. 이 중 가로 이동($R$) $m$번(또는 세로 이동 $n$번)을 언제 할지 선택하는 조합의 수와 같습니다.

### 3.2 공식

$$ \text{Paths} = \binom{m+n}{m} = \binom{m+n}{n} = \frac{(m+n)!}{m!n!} $$

## 4. 장애물이 있는 경우 (Handling Obstacles)

### 4.1 합의 법칙 사용 (권장)

장애물이 있는 지점의 경로 수를 0으로 취급하고, 덧셈을 계속 진행합니다. 실수를 줄이는 가장 좋은 방법입니다.

### 4.2 여사건 또는 경유점 사용

- **여사건:** (전체 경로) - (장애물을 통과하는 경로)
- **경유점:** 장애물을 피해서 반드시 지나야 하는 지점들을 잡아 구간별로 계산하여 더함. (복잡할 수 있음)

## 5. 예제 (Examples)

### 예제 1: 기본 격자 ($3 \times 2$)

가로 3칸, 세로 2칸인 격자에서 최단 경로 수는?

- **공식:** $\binom{3+2}{2} = \binom{5}{2} = 10$
- **합의 법칙:** 각 교차점에 숫자를 써서 더해 나가도 10이 나옴.

### 예제 2: 장애물 (Obstacle)

$3 \times 3$ 격자 정중앙에 호수가 있어 지나갈 수 없을 때 경로 수는?

- **합의 법칙 적용:**
  - (0,0)에서 시작.
  - (1,1) 지점(중앙)은 갈 수 없으므로 값을 0으로 처리하거나 계산에서 제외.
  - 주변 점들의 값을 더해 나가면 최종적으로 12가 나옴. (전체 $\binom{6}{3}=20$에서 중앙을 지나는 $\binom{2}{1}\times\binom{2}{1}=4$를 빼면 $20-4=16$이어야 하는데, 중앙이 점이 아니라 칸(Block)인지 교차점(Point)인지에 따라 다름. 보통 AMC 8에서는 교차점 장애물이나 특정 선분 삭제로 나옴. 여기서는 교차점 삭제 가정 시 12가 아닐 수 있음. **직접 더하는 것이 가장 정확함.**)

## 6. 코드 구현 (Code Implementation)

Python을 사용하여 합의 법칙(DP)으로 경로를 계산하는 코드입니다. 장애물 처리 기능을 포함합니다.

```python
def count_paths_dp(width, height, obstacles=None):
    """
    width: 가로 칸 수 (m)
    height: 세로 칸 수 (n)
    obstacles: 장애물이 있는 좌표 집합 set((x, y))
    """
    if obstacles is None:
        obstacles = set()

    # (width + 1) x (height + 1) 크기의 격자 생성 (교차점 기준)
    # dp[y][x]는 (x, y)까지 가는 경로의 수
    dp = [[0] * (width + 1) for _ in range(height + 1)]

    # 시작점 초기화
    dp[0][0] = 1

    for y in range(height + 1):
        for x in range(width + 1):
            # 장애물이면 패스 (경로 수 0 유지)
            if (x, y) in obstacles:
                dp[y][x] = 0
                continue

            # 왼쪽에서 오는 경우 더하기
            if x > 0:
                dp[y][x] += dp[y][x-1]
            # 아래쪽에서 오는 경우 더하기
            if y > 0:
                dp[y][x] += dp[y-1][x]

    return dp[height][width]

# 테스트: 3x2 격자 (장애물 없음)
print(f"3x2 Paths: {count_paths_dp(3, 2)}") # Expected: 10

# 테스트: 3x3 격자, 정중앙(1,1)과 (2,2) 사이의 특정 지점이 아니라 교차점(1,1)이 막힌 경우
# 좌표계: (0,0) ~ (3,3)
print(f"3x3 with obstacle at (1,1): {count_paths_dp(3, 3, obstacles={(1,1)})}")
```

## 7. 요약 (Summary)

- **직사각형 격자:** $\binom{m+n}{m}$ 공식이 가장 빠르다.
- **복잡한 격자/장애물:** 숫자를 직접 쓰는 **합의 법칙(Addition Method)**이 가장 안전하고 정확하다.
- **원리:** "여기까지 오는 방법 = 왼쪽에서 오는 법 + 아래에서 오는 법".
